[{"title":"Linux下挂载移动硬盘(ntfs格式)","url":"/archives/6e1b8bba.html","content":"#### 背景\n+ 上手树莓派，打算将弃用的笔记本硬盘挂在树莓派主机上，作为下载机使用\n+ 由于旧硬盘是win电脑拆下来的硬盘，磁盘格式为`Microsoft basic data`，也就是我们所说的NTFS格式，如果挂在Linux系统上，需要手动去挂载，并且防止出现文件乱码的情况\n+ 查找资料发现linux支持ntfs格式分区需要安装ntfs-3g软件，安装使用即可\n\n\n#### 安装ntfs-3g\n1. 通过编译安装\n    + 下载地址:[`https://www.tuxera.com/community/open-source-ntfs-3g/`](https://www.tuxera.com/community/open-source-ntfs-3g/)\n    + 下载好了之后，解压文件夹\n        + The latest stable version is ntfs-3g_ntfsprogs-2017.3.23, released on March 28, 2017.\n    + 进入文件目录\n        + `./configure`\n        + `make`\n        + `make install`\n    + 验证\n```\nroot@raspberrypi:/media/sda165# mkntfs -h\nFailed to set locale, using default 'C'.\nUsage: mkntfs [options] device [number-of-sectors]\nBasic options:\n    -f, --fast                      Perform a quick format\n    -Q, --quick                     Perform a quick format\n    -L, --label STRING              Set the volume label\n    -C, --enable-compression        Enable compression on the volume\n    -I, --no-indexing               Disable indexing on the volume\n    -n, --no-action                 Do not write to disk\nAdvanced options:\n    -c, --cluster-size BYTES        Specify the cluster size for the volume\n    -s, --sector-size BYTES         Specify the sector size for the device\n    -p, --partition-start SECTOR    Specify the partition start sector\n    -H, --heads NUM                 Specify the number of heads\n    -S, --sectors-per-track NUM     Specify the number of sectors per track\n    -z, --mft-zone-multiplier NUM   Set the MFT zone multiplier\n    -T, --zero-time                 Fake the time to be 00:00 UTC, Jan 1, 1970\n    -F, --force                     Force execution despite errors\nOutput options:\n    -q, --quiet                     Quiet execution\n    -v, --verbose                   Verbose execution\n        --debug                     Very verbose execution\n\nHelp options:\n    -V, --version                   Display version\n    -l, --license                   Display licensing information\n    -h, --help                      Display this help\n\nDevelopers' email address: ntfs-3g-devel@lists.sf.net\nNews, support and information:  http://tuxera.com\n```\n2. 使用Ubuntu的apt包管理器安装\n    + 搜索\n```\nroot@raspberrypi:/media/sda165# apt search ntfs-3g\nSorting... Done\nFull Text Search... Done\ndisk-manager/stable,stable 1.1.1-2 all\n  simple graphical filesystem configurator\n\nforensics-extra/stable,stable 2.8 all\n  Forensics Environment - extra console components (metapackage)\n\nlibntfs-3g883/stable,stable,now 1:2017.3.23AR.3-3 armhf [installed,automatic]\n  read/write NTFS driver for FUSE (runtime library)\n\nntfs-3g/stable,stable,now 1:2017.3.23AR.3-3 armhf [installed]\n  read/write NTFS driver for FUSE\n\nntfs-3g-dev/stable,stable 1:2017.3.23AR.3-3 armhf\n  read/write NTFS driver for FUSE (development)\n\nntfs-config/stable,stable 1.0.1-11+b1 armhf\n  Enable/disable write support for any NTFS devices\n```\n   + 安装\n        + 选择安装ntfs-3g软件`apt install ntfs-3g -y`\n#### 挂载\n1. 找到待挂载的硬盘(`fdisk -l`) 本页贴出自己挂载的硬盘信息(包括磁头、分区大小等信息)\n```\nDisk /dev/sdb: 465.8 GiB, 500107862016 bytes, 976773168 sectors\nDisk model: 545050A7E380    \nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 4096 bytes\nI/O size (minimum/optimal): 4096 bytes / 4096 bytes\nDisklabel type: gpt\nDisk identifier: 92159251-D30F-4F01-91A1-7122E899C63D\n\nDevice         Start       End   Sectors   Size Type\n/dev/sdb1    1083392 315269119 314185728 149.8G Microsoft basic data\n/dev/sdb2  315269120 524984319 209715200   100G Microsoft basic data\n/dev/sdb3  524984320 871014399 346030080   165G Microsoft basic data\n```\n2. 建立加载点\n```\nmkdir /media/sda100\n```\n3. 将对应的磁盘分区挂载在建立的文件夹\n+ 不关心是否出现乱码：`mount –t ntfs-3g /dev/sdi1 /media`\n+ 防止出现乱码(注：对ntfs格式的磁盘分区应使用-t ntfs-3g参数，对fat32格式的磁盘分区应使用-t vfat参数。若汉字文件名显示为乱码或不显示，可以使用下面的命令格式)：`mount -t ntfs-3g -o iocharset=cp936 /dev/sda2 /media/sda100`\n\n#### 验证结果(挂载了三个盘)\n+ `# df -h`\n```\nroot@raspberrypi:/media/sda165# df -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/root        15G  1.6G   13G  12% /\ndevtmpfs        1.8G     0  1.8G   0% /dev\ntmpfs           2.0G     0  2.0G   0% /dev/shm\ntmpfs           2.0G  139M  1.8G   8% /run\ntmpfs           5.0M  4.0K  5.0M   1% /run/lock\ntmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup\n/dev/mmcblk0p1  253M   40M  213M  16% /boot\ntmpfs           391M     0  391M   0% /run/user/0\n/dev/sda1       150G  135G   16G  90% /media/sda150\n/dev/sda2       100G   95G  5.5G  95% /media/sda100\n/dev/sdb3       165G  150G   16G  91% /media/sda165\n```\n\n#### 设置系统重启之后自动挂载硬盘\n+ 获取磁盘分配的UUID(前提是硬盘挂载成功的基础上)\n    + `sudo blkid`\n```\nroot@raspberrypi:~# blkid \n/dev/mmcblk0p1: LABEL_FATBOOT=\"boot\" LABEL=\"boot\" UUID=\"B6BB-0F0E\" TYPE=\"vfat\" PARTUUID=\"8337a7e9-01\"\n/dev/mmcblk0p2: LABEL=\"rootfs\" UUID=\"638417fb-7220-47b1-883c-e6fee02f51ac\" TYPE=\"ext4\" PARTUUID=\"8337a7e9-02\"\n/dev/sda1: LABEL=\"M-fM-^VM-0M-eM-^JM- M-eM-^MM-7\" UUID=\"ECB83FE3B83FAB4A\" TYPE=\"ntfs\" PARTLABEL=\"Basic data partition\" PARTUUID=\"8f9ec6c4-605d-4a29-aad4-bd2cb8b09424\"\n/dev/sda2: LABEL=\"M-hM-5M-^DM-fM-^VM-^Y\" UUID=\"96B6EEE9B6EEC8B7\" TYPE=\"ntfs\" PARTLABEL=\"Basic data partition\" PARTUUID=\"fbf23a39-686c-448c-a0c6-da8a4b1408a4\"\n/dev/sda3: LABEL=\"M-fM-^VM-0M-eM-^JM- M-eM-^MM-7\" UUID=\"C4B604C3B604B846\" TYPE=\"ntfs\" PARTLABEL=\"Basic data partition\" PARTUUID=\"58bcdce9-7f85-4bc3-84d1-15eb6f23c3b7\"\n/dev/mmcblk0: PTUUID=\"8337a7e9\" PTTYPE=\"dos\"\n```\n+ 配置开机自动挂载\n    + 因为mount命令会在重启服务器后失效，所以要将分区信息写到/etc/fstab文件中让它永久挂载\n    + 配置\n        + 在文件`/etc/fstab`添加UUID配置\n        + 规则\n```\n<fs spec> <fs file> <fs vfstype> <fs mntops> <fsfreq> <fs passno>\n具体说明，以挂载/dev/sdb1为例:\n<fs spec> :\n分区定位，可以给UUID或LABEL，例如：UUID=6E9ADAC29ADA85CD或LABEL=software\n<fs file> : 具体挂载点的位置，例如：/data\n<fs vfstype> : 挂载磁盘类型，linux分区一般为ext4，windows分区一般为ntfs\n<fs mntops> : 挂载参数，一般为defaults\n<fs freq> : 磁盘检查，默认为0\n* <fs passno> : 磁盘检查，默认为0,不需要检查\n\n```\n        + 我的配置\n```     \nUUID=ECB83FE3B83FAB4A /media/sda150 ntfs defaults 0 1\nUUID=96B6EEE9B6EEC8B7 /media/sda100 ntfs defaults 0 1\nUUID=C4B604C3B604B846 /media/sda165 ntfs defaults 0 1\n```\n    + 配置完成之后验证自动挂载参数是否正确`mount -a`;如果参数配置不正确，可能会导致系统无法启动(卒)......","tags":["Linux","Raspberry"]},{"title":"Redis持久化方案","url":"/archives/27e17559.html","content":"#### 持久化方案有2种:\n##### `Rdb`: 快照形式\n+ 定期把内存中当前时刻的数据保存在硬盘中，是Redis默认支持的持久化方案\n+ `Rdb`是一个半持久化模式，即按照一定的策略周期将数据保存在磁盘中，其中保存数据的文件为`dump.rdb`\n+ 在Redis服务重启的时候，会执行一遍备份文件中的数据\n+ `Rdb`配置文件的默认配置方式如下(可见redis.conf)\n```\nsave 900 1    #当有一条Keys数据被改变时，900秒刷新到Disk一次\nsave 300 10   #当有10条Keys数据被改变时，300秒刷新到Disk一次\nsave 60 10000 #当有10000条Keys数据被改变时，60秒刷新到Disk一次\n```\n+ snapshot快照持久化Redis的文件持久化方式，决定了其在持久化的时候，有可能会出现数据丢失的情况，如果Redis服务器发生故障，那么故障前保存在内存中的数据可能没有命中持久化周期，可能会丢失。\n+ 同时Redis的RDB文件，也是主从复制内部实现的重要一环\n    1. 第一次Slave向master同步的实现：Salve向master发出请求同步的时候，master将数据dump到RDB文件中，然后将RDB文件全量传输给Slave，然后发送执行快照恢复的命令给Slave，实现初次同步\n    2. 第二次以后的同步：master将变量的快照直接实时同步给Slave\n    3. 只要master和Slave法师断开和重连，肯定会发生以上两个同步工序，Redis主从复制是建立在内存快照的持久化基础上的，只要有Slave就一定会有内存快照发生。\n\n##### `AOF`形式\n+ `AOF`持久化时，Redis会将每一个收到的写命令都通过`write`函数追加到文件中，类似mysql的binlog，当服务器重启当时候，会执行该持久化文件进行数据恢复\n+ 对应的参数配置如下(redis.conf)：\n```text\nappendonly yes       #启用AOF持久化方式\nappendfilename appendonly.aof #AOF文件的名称，默认为appendonly.aof\n# appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。\nappendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。\n# appendfsync no     #完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。\n```\n+ `AOF`持久化类似于日志记录形式，每条数据的改变记录都会记录在AOF文件中，随着数据操作次数变多，AOF文件越来越臃肿，但是对于一个键值的操作，在进行数据恢复的时候，只有一条数据记录是有效的\n为了压缩AOF文件，Redis提供bgrewriteaof命令，收到此命令的时，Redis使用与快照的方式，将内存中数据以命令的方式保存在临时文件中，最后替换原来的文件，以此控制AOF文件的增长\n+ `bgrewriteaof`使用配置如下：\n```text\nno-appendfsync-on-rewrite yes   #在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，避免与命令的追加造成DISK IO上的冲突。\nauto-aof-rewrite-percentage 100 #当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。\nauto-aof-rewrite-min-size 64mb  #当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。\n```\n\n#### 持久化方案的选择\n+ 如果能接受数据灾难带来的前几分钟的数据丢失，推荐使用RDB持久化形式\n+ 如果考虑到完全使用AOF持久化会带来性能方面的问题，比如持久化带来阻塞等，可以使用RDB和AOF配合使用，RDB可以定期保存一份完整的快照，而AOF能保证减少数据丢失，提高数据保障性","tags":["Redis"]},{"title":"数据库锁机制分类","url":"/archives/3eac123.html","content":"##### 按照封锁类型分类\n+ 排他锁(`X锁`)：又称为写锁；如果当前事务获得X锁，会阻塞其他事务的读与写，当前事务释放当前对象的X锁之前，其他事务不能对当前对象进行读或者写；\n+ 共享锁(`S锁`)：又称为读锁；如果当前事务获得了S锁，其他事务只能再对当前对象加S锁，而不能加X锁，保证其他事务可以读当前对象，不可用对当前对象作出更改\n\n##### 按照锁的封锁类型分类\n+ 行级锁(`MySql InnoDb`支持)\n\t1. 优点：锁定粒度小(最小), 发生锁冲突的几率最低，并发度也最高；\n\t2. 缺点：获取锁与释放锁需要的开销比较大；会出现死锁；如果大部分数据操作涉及到`order by`或者全表扫描的情景，效率明显比其他锁要慢\n+ 表级锁\n\t1. 优点：开销小，加锁与释放锁效率高\n\t2. 缺点：锁定粒度大，发生锁冲突的概率高，并发度低。\n+ 页级锁(`MySql`特有)\n\t1. 优点：锁定粒度处于两个极端(行级锁与表级锁)之间；所以并发处理能力也处于上面两者之间\n\t2. 缺点：页级锁定和行级锁定一样，会发生死锁\n+ 什么时候使用表级锁？\n    + 对于InnoDB，大多数情况下都是选择使用行级锁；因为行级锁和事务支持是我们选择使用InnoDB的理由；\n    + 但是，也存在特殊情况：\n        1. 事务需要更新大部分或者全部数据，表又比较大，如果使用默认的行锁，处理每条数据都需要进行加锁和释放锁的操作，导致开销非常大，事务执行效率底下；也可能导致其他事务长时间等待或锁冲突；这种情况适合采用锁表来提高事务的执行效率；\n        2. 事务操作设计到的表比较多，并且复杂，容易引起死锁，或者可能造成大量事务回滚。这样情况也可以考虑使用表锁进行数据库性能上的优化；\n        \n\n##### 按照锁的使用方式划分\n+ 悲观锁\n    1. 悲观并发锁(`PCC`)：总是假设最坏的情况，每次去操作数据的时候，都认为别人会进行修改，所以每次操作数据的时候都会上锁，这样别人想操作这个数据的时候，就会阻塞，知道锁被释放；共享资源每次只给一个线程\\事务使用，其他线程阻塞，锁被释放才会转让操作权\n    2. 使用场景：适用于多写情景下；避免数据冲突导致的数据不一致的问题\n+ 乐观锁\n    1. 乐观并发锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，不会加锁； 但是再更新到时候，都会判断一下在此期间别人有木有更新这个数据，这个检查的实现可以是通过版本号机制和CAS算法实现\n    2. 使用场景：适用于多读情景下；数据冲突发生少，可以省去锁开销","tags":["Mysql"]},{"title":"RabbitMQ消息可靠性","url":"/archives/7ffea1fe.html","content":"#### RabbitMQ服务器数据不丢失\n+ 在`RabbitMQ`服务器中，我们通过持久化数据，来保证服务器故障或重启之后，能够恢复数据来防治数据丢失\n+ 在定义`channel`的时候, 设置该通道的消息持久化。\n#### 消息生产者传输到服务器不丢包\n+ 事务控制： 使用AMQP的自带的事务管理模式确保消息已经发送到RabbitMQ服务器，但是会带来更大的吞吐量，大量消息发送\n+ 使用Confirm模式确认(异步)\n\t1. 将生产者`Channel`设置为`Confirm`模式，一旦`channel`进入`confirm`模式之后，所有在该信道上面发布的消息都会指派一个唯一的Id，一旦消息被投递到所匹配的队列之后，Broker就会发送一个确认给生产者，这样生产者就知道了消息已经到达目的地。\n\n#### 确认消费者已经正常处理消息\n+ 为了保证消息正常的到达消费者，RabbitMQ提供了消息的`acknowledgement`来确认消息\n+ 默认的消息确认设置是自动确认，且服务端不记录确认结果(`autoAck=None; isAutoAck=false`)；`autoAck=None;`表示消息发送现实的回复确认之后，消息才从服务器中移除，但是`acknowledgement`设置了Auto的话，那么`isAutoAck=true`就不安全了。消息发送出去之后，可能还没到达消费者，TCP链接就断开，因为配置了auto，消息发出之后，就移除消息，默认消费者已经正常处理。\n+ 还可以设置`autoAck=Normal; isAutoAck=false`，那么每次的消息确认操作，就需要消费者手动确认(`basc.ack,basic.nack等`),消息从服务器队列中移除或者重新入队。\n","tags":["RabbitMQ"]},{"title":"快速失败与安全失败机制","url":"/archives/28d7adef.html","content":"#### 快速失败机制(`fail-fast`)\n+ 在迭代器迭代的时候对集合进行修改：\n\n`案例代码：`\n```\nList<String> list = new ArrayList<>();\nlist.add(\"UML\");\nlist.add(\"PDF\");\nlist.add(\"VRP\");\n// 1. 使用iterator遍历的时候发生更改，会导致 ConcurrentModificationException\n//        Iterator iterator = list.iterator();\n//        while (iterator.hasNext()) {\n//            list.remove(1);\n//        }\n//2. 使用foreach遍历的时候发生更改，会导致 ConcurrentModificationException\n//        for (String str : list){\n//            list.remove(1);\n//        }\n//3. 使用for i 的形式遍历的时候发生更改，不会导致 ConcurrentModificationException。\n//        for (int i = 0; i < list.size(); i++) {\n//            list.remove(1);\n//        }\n\n```\n`执行的异常结果：`\n```\nException in thread \"main\" java.util.ConcurrentModificationException\n\tat java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)\n\tat java.util.ArrayList$Itr.next(ArrayList.java:859)\n```\n`结果分析：`当迭代器遍历一个集合对象的时候，对集合对象进行内容修改(包括：赠删改)，则会抛出异常：`ConcurrentModificationException`\n+ 《Java编程思想》对快速失败(快速报错)的解释\n\t1. Java容器有一种保护机制，能够防止多个进程同时修改一个容器的内容。如果你正在迭代遍历某个容器的过程中，另一个线程对介入，并插入、删除、或修改容器中的某个对象，那么就会出现问题：也许迭代过程中已经处理了该对象，也许没有处理，也需要在调用`size()`方法之后容器的尺寸收缩了-----还有许多的灾难情景。\n\t2. Java容器类类库采用`快速报错(fail-fast)`机制。它会探查容器上任何除了你的线程所进行的操作以外其他的所有变化，一旦发现其他线程对容器进行修改，就会立刻抛出`ConcurrentModificationException`异常\n\t3. 引用自书籍《Java编程思想》`17.11.3`章节\n+ 快速失败原理：\n\t+ 迭代器在便利一个集合对象时，并且在遍历过程中使用一个`modCount`变量。集合在遍历期间如果内容发生变化，就会改变`modCount`的值。每当迭代器使用`hashNext()/next()`遍历下一个元素的时候，都会检测`modCount`变量是否为`expectedmodCount`的值，如果是，则返回便利；否则抛出异常，终止便利。这里异常的抛出条件是检测到 `modCount！=expectedmodCount` 这个条件。如果集合发生变化时修改`modCount`值刚好又设置为了`expectedmodCount`值.\n\t+ 场景参考：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改(指的是迭代过程中被修改)\n#### 安全失败机制(`fail-safe`)\n+ java.util.concurrent包下list执行迭代时修改操作\n```\n        //同样的代码：采用具备安全失败(fail-safe)的集合容器来创建对象\n        List<String> list = new CopyOnWriteArrayList<>();\n        list.add(\"UML\");\n        list.add(\"PDF\");\n        list.add(\"VRP\");\n        // 1. 使用iterator遍历的时候发生更改，不会导致 ConcurrentModificationException\n//        Iterator iterator = list.iterator();\n//        while (iterator.hasNext()) {\n//            list.remove(1);\n//            break;\n//        }\n        //2. 使用foreach遍历的时候发生更改，不会导致 ConcurrentModificationException\n//        for (String str : list){\n//            list.remove(1);\n//            break;\n//        }\n        //3. 使用for i 的形式遍历的时候发生更改，不会导致 ConcurrentModificationException。\n//        for (int i = 0; i < list.size(); i++) {\n//            list.remove(1);\n//            break;\n//        }\n```\n`执行正常`\n+ 安全失败机制\n\t+ 原理：由于迭代的时候，对原集合的拷贝进行遍历，所以在遍历过程中，对原集合所做的修改不能被迭代器检测到，所以不会触发`ConcurrentModificationException`异常\n\t+ 缺点：基于拷贝内容的容器虽然是避免来`ConcurrentModificationException`异常，但是同样地，拷贝出来的内容不能同步到原集合中内容信息的修改，可能会造成容器数据版本落后。\n\t+ 场景参考：`java.util.concurrent`包下的容器都是安全失败的，可以在多线程并发下使用，并发修改。\n\t+ 快速失败，安全失败是相对于迭代器而言的，包括iterator和foreach，不包括for i ；","tags":["Java"]},{"title":"Integer封装类比较大小","url":"/archives/a1cd7aa8.html","content":"#### 先上Demo，Integer数据的比较大小\n```java\npublic static void main(String[] args) {\n        Integer a = 128;\n        Integer b = 128;\n        //test-1\n        if (a == b) {\n            System.out.println(\" a is equal to b\");\n        }\n        Integer c = 127;\n        Integer d = 127;\n        //test-2\n        if (c == d) {\n            System.out.println(\"c is equal to d\");\n        }\n        int e = 128;\n        //test-3\n        if (a == e) {\n            System.out.println(\"a is equal to e\");\n        }\n        int f = 127;\n        //test-4\n        if (f == c) {\n            System.out.println(\"f is equal to c\");\n        }\n        Integer g = 129;\n        //test-5\n        if (g > a) {\n            System.out.println(\"g is larger to a\");\n        }\n        //test-6\n        if (g > c) {\n            System.out.println(\"g is larger to c\");\n        }\n\n        /**\n         * 结果：\n         *    c is equal to d\n         *    a is equal to e\n         *    f is equal to c\n         *    g is lager to a\n         *    g is larger to c\n         * */\n\n    }\n```\n\n#### 测试点分析\n1. `test-1`：Intger数值超出`Integer.MinValue（-128）`和`Integer.MaxValue（127）`的范围，用等号比较大小，数值不等\n2. `test-2`：Intger数值在`Integer.MinValue（-128）`和`Integer.MaxValue（127）`的范围内，用等号比较大小，数值相等\n3. `test-3`和：`test-4`：Integer数值在Integer范围内或者范围外与int基本数据类型进行比较；只要数值相等，两者都相等\n4. `test-5`和：`test-6`: Integer数值在不超出int的范围内进行比较，只比较数值的大小\n\n#### 实验结果总结\n+ 在-128~127的Integer值并且以Integer x = value;的方式赋值的Integer值在进行==和equals比较时，都会返回true；因为在此范围内的Integer的数值用的是原生数据类型int，会在内存中重用；比较的时候，只比较数值大小\n+ 超出-128~127的Integer的数值比较的时候，不仅比较数值的大小，还比较对象的引用地址是否一致\n+ 而Integer类型与int比较大小的时候，只比较数值大小；因为Integer会自动拆箱操作，转换成int类型再进行比较\n+ 对于超出-128~127的Integer比较数值是否相等的时候，采用`equal()`方法进行比较;但是实际生成环境中，无法确定Integer的范围时候，只能都用`equal()`进行Integer类型的大小比较;\n+ jdk中`equal()`源码如下：\n```java\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value == ((Integer)obj).intValue();\n        }\n        return false;\n    }\n```\n","tags":["Java"]},{"title":"Nginx的负载均衡策略","url":"/archives/9b0bd708.html","content":"#### Nginx负载均衡模块的作用\n1. 负载均衡模块用于从”upstream”指令定义的后端主机列表中选取一台主机。nginx先使用负载均衡模块找到一台主机，再使用upstream模块实现与这台主机的交互。\n2. Nginx负载均衡默认对后端服务器有健康检测的能力，仅限于端口检测，在后端服务器比较少的情况下负载均衡能力表现突出。\n3. 提醒：各种负载均衡策略尽量不要混合使用，这样会导致负载不均衡。\n#### Nginx负载均衡策略\n1. 轮询策略(`round-robin`)\n    + 轮询策略是Nginx自带的负载均衡策略，并且是默认的策略。\n    + 每个请求按照访问时间顺序，分配到不同的后端服务器\n    + 配置如下：\n```\nupstream backend {\n       server 192.168.1.101:8888;\n       server 192.168.1.102:8888;\n       server 192.168.1.103:8888;\n   }\n```\n2. 权重策略(`weight`)\n    + 被指为轮询负载均衡策略的加强版，可以指定每个可选项的轮询频率\n    + 可以根据后端服务器的异质，能承受的负载程度来使用此策略\n    + 配置如下：\n```xml\nupstream backend { \n    server 192.168.1.101 weight=1; \n    server 192.168.1.102 weight=2;\n    server 192.168.1.103 weight=3;\n}\n```\n\n3. 基于IP的哈希策略(`ip_hash`)\n    + 按照每个访问IP的hash计算结果来分配访问指定的后端服务器；这样可以对固定的访问源转发到固定的目的地址\n    + 这样可以解决集群中session一致性的问题\n    + 配置如下：\n```xml\nupstream backend { \n    ip_hash; \n    server 192.168.1.101:7777; \n    server 192.168.1.102:8888;\n    server 192.168.1.103:9999;\n}\n```\n4. 公平分配策略(`fair`)(来自第三方)\n    + 公平的按照后端服务器的响应时间(`rt`)来分配请求，响应时间短的优先分配访问\n    + 由于这种是第三方的负载均衡策略，如果Nginx要使用的话，需要往Nginx里面下载upstr_fair模块\n    + 配置如下：\n```xml\nupstream backend { \n   fair;\n   server 192.168.1.101; \n   server 192.168.1.102; \n   server 192.168.1.103; \n}\n```\n5. 基于URL的哈希策略(`url_hash`)(来自第三方)\n    + 与IP_Hash类似，URL_Hash是根据请求的URL地址做哈希计算来分配请求值，力求每个相同的URL都能访问到相同的后端服务器\n    + 该策略主要用于缓存场景。根据缓存服务的请求参数，能提高命中同一台后端缓存服务器\n    + 使用的时候，同样，由于URL哈希属于第三方的负载均衡策略，要使用的话，需要按照这种负载均衡模块包以及指定哈希算法的hash软件包\n    + 配置如下：其中`hash_method`是哈希算法\n<pre>\nupstream backend {\n    server 192.168.1.101; \n    server 192.168.1.102; \n    server 192.168.1.103; \n    hash $request_uri; \n    hash_method crc32;\n}\n<pre>","tags":["Nginx","NetWorker"]},{"title":"Java遍历Map对象的4种方法","url":"/archives/d1b4efa1.html","content":"#### Foreach遍历Map.Entry对象（O(n)）\n+ 最普遍的遍历方式。但是遍历的Map不可为Null，需要做空指针判断\n```\n    //foreach遍历Entry实例\n    public static void forEachMap(Map<String,String> stringMap){\n        if (stringMap==null) return;    //如果要遍历的Map为空，则终止遍历#NullPointerException\n        for (Map.Entry<String,String> entry : stringMap.entrySet()){\n            System.out.println(\"key:\"+entry.getKey()+\",value:\"+entry.getValue());\n        }\n    }\n```\n\n#### Foreach直接遍历key/value （O(n)）\n+ 通过Map的`keySet()`和`getValues()`对象直接获取key/value集合，再遍历得到数据\n```\n    //单独遍历Map对象中的key/value\n    public static void forEachKeyOrValue(Map<String,String> map){\n        for (String key : map.keySet()){\n            System.out.println(\"key:\"+key);\n        }\n        for (String value : map.values()){\n            System.out.println(\"value:\"+value);\n        }\n    }\n```\n\n#### 根据取出来的key集合来遍历value （O(n*n)）\n+ 这种方法有种多此一举的感觉...\n```\n     /**\n     * 先取出Map的key值，再通过遍历取出来的key来获取value值\n     * 但是该方法效率低，取出key已经很消耗资源，再遍历一遍value，已经是翻倍的成本\n     * */\n    public static void forEachByKey(Map<String,String> map){\n        for (String key : map.keySet()){\n            System.out.println(\"key:\"+key+\",value:\"+map.get(key));\n        }\n    }\n```\n\n####使用迭代器遍历Map对象 \n+ 使用迭代器遍历Map的泛型数据`（O(n)）`\n```\n//通过迭代器Iterator遍历Map，使用泛型\n    public static void iteratorMap(Map<String,String> map){\n        Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();\n        while (iterator.hasNext()){\n            Map.Entry<String,String> entry = iterator.next();\n            System.out.println(\"key:\"+entry.getKey()+\",value:\"+entry.getValue());\n        }\n    }\n```\n+ 使用迭代器遍历键值数据`（O(n*n)）`\n```\n    /**\n     * 先取出Map的key值，再通过遍历取出来的key来获取value值\n     * 但是该方法效率低，取出key已经很消耗资源，再遍历一遍value，已经是翻倍的成本\n     * */\n    public static void forEachByKey(Map<String,String> map){\n        for (String key : map.keySet()){\n            System.out.println(\"key:\"+key+\",value:\"+map.get(key));\n        }\n    }\n```\n","tags":["Java"]},{"title":"Array与Arrays的区别","url":"/archives/1ab741e2.html","content":"\n#### `Array`数组类\n+ `Array`数组是Java提供的一个基本的存储结构\n+ 提供了动态创建和访问 Java 数组的方法。其中的元素的类型必须相同\n+ 效率高，但是容量固定且无法改变；如果涉及扩展，需要重新创建数组并复制数据\n\n#### `Arrays`静态类\n+ `Arrays`是一个数组的工具类，专门用于操作数组\n+ 具备齐全的处理工具方法；例如：搜索，排序，复制等静态方法","tags":["Java"]},{"title":"Collection与Collections的区别","url":"/archives/ad76721a.html","content":"\n#### `java.util.Collection`是一个集合接口\n+ `Collection`是个接口类，旗下派生出我们常用以及不常用的一些容器，如下：\n+ `java.util.Collection`\n    + Queue\n    + Set\n        + AbstractSet\n            + HashSet\n                + LinkedHashSet\n            + TreeSet\n        + SortSet\n    + List\n        + AbstractList\n            + ArrayList\n            + AbstractSequentialList\n                + LinkedList\n            + Vector\n                + Stack\n\n#### `java.util.Collections` 是一个静态工具类\n+ `java.util.Collection`主要用于操作集合容器，工具方法齐全\n+ 提供一系列的静态方法实现对各种几何的搜索、排序、线程安全化等操作","tags":["Java"]},{"title":"Set集合误用引发的血案","url":"/archives/130dac3d.html","content":"\n#### 需求场景：\n\n1. 功能开发完成了，准备发布版本，准备下班。\n2. 从Redis的`Zset`的结构中，根据`score`的倒序取出有序集合数据\n\n#### 罪魁祸首的业务代码\n\n```\npublic static Set<String> getZsetOrderByScore(final String key,final Long start , final Long end){\n\t\ttry {\n\t\t\treturn redisTemplate.execute(new RedisCallback<Set<String>>() {\n\t\t\t\t@Override\n\t\t\t\tpublic Set<String> doInRedis(RedisConnection redisConnection) throws DataAccessException {\n\t\t\t\t\tSet<byte[]> set = redisConnection.zRevRange(redisTemplate.getStringSerializer().serialize(key),start,end);\n\n\t\t\t\t\tSet<String> s = set.parallelStream().map(bytes -> {\n\t\t\t\t\t\treturn redisTemplate.getStringSerializer().deserialize(bytes);\n\t\t\t\t\t}).collect(Collectors.toSet());\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (Exception e) {\n\t\t\tDEBUG.error(\"getZsetWithCol value to redis fail...\", e);\n\t\t}\n\t\treturn Collections.emptySet();\n\t}\n```\n\n#### 引发问题：\n\n1. Redis中的`ZSet`数据排序正常，`score`的顺序也正常，经过上面代码取出来之后,`Set<String>`集合中的数据排序与Redis中的`ZSet`数据排序不一致。导致数据展示错误\n2. 出现问题，不能发版本，deadline在这，还是得把问题解决。\n\t\n#### 问题排查：\n\n1. 把刚刚从Redis中取出来的数据，反序列化之后，直接打印出来，发现数据顺序与Redis一直；排除Java代码从Redis中查询数据的时候发生顺序错误这个猜测\n2. 随着数据流向，问题定位网上抛。判断刚刚反序列化就打印的数据顺序与`Set<String>`容器对象中的顺序，发现两者顺序不一致，发生顺序错误。\n3. 问题定位在反序列化数据之后，装载在`Set<String>`容器的时候，发送顺序错乱。\n\n#### 问题分析：\n+ 使用lambda表达式的时候，聚合集合操作`Collectors.toSet()`打乱了数据的顺序\n+ `Collectors.toSet()`本质是重新组装`Set`集合，先看看`Set`集合是否会对集合对象进行重新排序？\n<pre>\nSet<String > set = new HashSet<>();\n        set.add(\"m\");\n        set.add(\"a\");\n        set.add(\"e\");\n        System.out.println(set);\n        //打印结果：[a, e, m]\n<pre>\n+ 果然问题出现在这里，幸好没去翻lambda的聚合源码\n+ HashSet内部使用元素的自然顺序对元素进行排序，或者根据创建set时提供的Comparator进行排序\n+ HashSet使用哈希函数对数据进寻址排序，所以数据是重新排序过的。\n\n#### BUG FIXED\n1. 在从取出来的数据反序列化完成之后，不使用`Set`集合来存方对象，使用`List`代替之。\n2. 如果能获取到Redis数据的score数值的话，也可以通过重写Comparator方法，来通过score数据排序。","tags":["Java","Redis","TakeDown"]},{"title":"基于Redis缓存的音频点赞排行榜功能实践","url":"/archives/4354712f.html","content":"\n##### 需求背景\n+ 情人节情话音频点赞排行榜功能：用户录制并上传一段音频，分享朋友/朋友圈，用户(包括自己)对录制的音频进行点赞，并根据点赞数量排序(排行榜)，并且，一个用户每天只能点赞一次，第二天可以继续点赞。\n\n##### 数据结构\n+ DB表：\n\t1. 音频信息表：包括音频的基本信息，音频的被点赞总数量\n\t2. 点赞信息表：包括每个音频被用户的点赞情况，不保存取消点赞的行为信息\n+ 缓存结构：\n\t1. `缓存结构1`:音频信息列表通过字符串的结构保存到缓存中，每个音频信息一个key，对应一个音频信息对象的序列化`JSON`数据，取出来的时候，反序列化下。但是其中的点赞数据以`[2]`中的`zSet`结构保存的点赞数量为主。\n\t2. `缓存结构2`:音频排行榜通过`zSet`结构保存，每条记录的`score`参数为音频的点赞数量\n\t3. `缓存结构3`:音频的点赞情况，即音频id与点赞用户id的对应关系，用`Set`结构保存一个音频，对应的点赞用户。因为需要满足不可重复点赞的功能，通过`Set`结构来对数据去重。另外，由于需求中提到一天之内点赞一次，所以，这个数据去重只能一天设置一个统计结构。所以，这个`Set`结构的key应该与日期联系起来，保证隔天之后，用户可以再次点赞，以及用户的点赞数据尽量持久化到DB中。\n\n\n#### 技术方案\n+ 用户上传录制音频：\n\t1. 前端的小伙伴负责，音频信息保存在微信的临时素材中，不过只能保持三天；\n\t2. 如果过了三天怎么办？通过获取前端上传给微信临时素材的id，后端在素材即将过期的时候，对素材进行续传，获取新的音频素材id；通过定时任务解决。\n\t3. 点赞数据上传完毕，并将该条信息初始化到缓存中，包括缓存基础信息、缓存排行榜的排序列表、点赞情况信息缓存则在用户点赞之后再创建这个结构。\n+ 用户点赞/取消点赞：\n\t1. 点赞/取消点赞的时候，发起异步请求，将请求结果保持在`Redis`缓存中\n\t2. 如果是点赞信息，则添加到点赞情况缓存中，如果是取消单赞，则在缓存中去掉该用户的点赞信息。\n+ 排行榜数据：\n\t+ 读取：数据从缓存排行榜中获取所有音频信息的排序，根据这个排序，根据音频id，从`缓存结构1`中将音频的详细信息反序列化出来，其中的点赞数据采用`ZSet`结构的`score`\n\t+ 持久化：将缓存中的点赞数据缓存到DB中。何时进行持久化？在缓存中设置一个持久化周期时间标记，每次用户点赞的时候，检测这个持久化标记，达到了持久化周期，则对数据进行持久化，写入DB中。由于涉及到日期变更，缓存数据重置的问题，在持久化的时候，对前一天的保存点赞情况的`Set`结构的key检测一下存在性，如果存在，则先将该部分数据进行持久化，持久化成功之后，将这个key删除；后续再进行当天缓存数据的持久化操作。","tags":["Java","Redis","场景"]},{"title":"Redis基础数据结构","url":"/archives/e8fc0d11.html","content":"\n##### Redis数据简述\n+ 经常用来存储字符串，哈希结构，链表集合\n+ Redis与memcached对比\n\t+ Redis可以用来做存储又可以做缓存，而memcached做缓存。主要因为redis具备持久化能力\n\t+ Redis存储的数据多种结构(字符串，哈希结构，链表，集合，有序集合等)，而memcached只有一种存储结构(字符串)\n\t+ redis支持数据的备份，即master-slave模式的数据备份；\n\n##### 通用数据维护指令\n\n1. keys `pattern` : 模糊查询 pattern为正则查询(`eg. keys [C|L]*`);\n2. RANDOMKEY : 返回随机的key\n3. TYPE keyname : 查询key的类型\n4. EXISTS keyName : 判断是否存在key\n5. DEL keyname 删除key\n6. RENAME old new 从新命名\n7. RENAMENX  判断新key是否会重名，如果已经存在新的key名，则操作失败\n8.  MOVE key db 移动数据到另一个库\n9.  ttl key  查询key有效期，-1表示永久有效 -2表示已经过期\n10.  EXPIRE key seconds 设置key的有效期，如果不设置，则永久有效\n11.  PEXPIRE key milliseconds 以毫秒为单位设置key的生命周期\n12.  PERSIST key 取消key的有效期限制\n\n#####  Redis数据结构操作指令说明\n+ 结构操作指令说明\n\t1. Redis数据除了普通的通用指令之外，其他的指令都是针对Redis的四种数据结构，对数据的维护，包括增删查改。\n\t2. 而每个数据结构的增、删、查、改再进行细化操作，又有多种更加细分的操作指令。\n\t3. 只要按照这个思路，对Redis数据结构的花样维护这个思路去深入了解Redis的操作。\n+ 字符串操作\n\t1.  `SET key value [expiration EX seconds(秒)|PX milliseconds(毫秒)] [NX|XX] `：设置字符串类型，后面可选参数，设置有效周期，用毫秒或者秒作为生命周期，而且，只能设置一个标准，如果选了两个，则以最后一个为准。nx表示key不存在的时候，才操作成功、xx表示key存在的时候才操作成功，可以用来区分创建或者新增操作。\n\t2.  ` MSET key value [key value ...] `一次创建多个k-v数据( MSET key1 \"Hello\" key2 \"World\")\n\t3.  get key 获取key的值\n\t4.  `MGET key1 key2`获取多个key的值\n\t5.  ` SETRANGE key offset value `在指定的偏移值对字符进行替换，如果缺数据，则以0代替\n\t6.  get key\n\t7.  `GETRANGE key start end` 根据范围取key值\n\t8.  `APPEND key value `在key的值后面增加数据\n\t9.  ` GETSET key value`获取旧的值，同时设置新的值，用来获取状态并更新状态\n\t10.  `INCR key` 执行设置key值+1操作，并返回计算后的数据(减少为decr key)\n\t11.  ` INCRBY key increment `通过步进频率来增加\n\t12.  `SETBIT key offset value` 位操作：设置字符的二进制值，而改变字符对值，比如大小写字母ascii相差32，修改对应位置的0或者1，即可进行大小写转换\n\n+ 链表结构(List)类型\n\t1. 增加值：[L|R]PUSH key value\n\t2. 去掉值：[L|R]POP key\n\t3. 删除值：`LREM key count value `count表示删除标示，如果count为正数，从头部往尾部删除，count为负数，从尾部开始删，如果为0，则删除所有匹配值的数据\n\t4. 查看长度：`LLEN key`\n\t5. 在匹配的值前后插入值：`LINSERT key BEFORE|AFTER pivot value`\n\t6. 两个链表之间迁移数据: `RPOPLPUSH source destination `\n+ 集合结构(`SET`)\n\t1. 特点：无序性、确定性、唯一性,支持多个集合之间的交集、并集运算\n\t2. `SADD key member1 [member2] `往Set集合中添加成员数据，一条指令，可以添加一个或者多个成员数据\n\t3. `SCARD key `获取集合的成员数\n\t4. `SISMEMBER key member `判断 member 元素是否是集合 key 的成员\n\t5. `SMEMBERS key `返回集合中的所有成员\n\t6. `SRANDMEMBER key [count] `返回集合中一个或多个随机数,具体实际使用场景可实际斟酌使用\n\t7. `SREM key member1 [member2] `移除集合中一个或多个成员\n\t8. 交集运算：\n\t\t+ `SINTER key1 [key2] `返回给定所有集合的交集\n\t\t+ `SINTERSTORE destination key1 [key2] `返回给定所有集合的交集并存储在 destination 中\n\t9. 并集运算：\n\t+ `SUNION key1 [key2] `返回所有给定集合的并集\n\t+ `SUNIONSTORE destination key1 [key2] `所有给定集合的并集存储在 destination 集合中\n+ 有序集合(`sorted set`)\n1. 有序集合的数据结构表现形式为`score(分数值) member(成员)` ,`score`主要是用于排序(不必须唯一)，而`member`为集合的成员(必须唯一)\n2. 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\n3. 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)\n4. `ZADD key score1 member1 [score2 member2] `向有序集合添加一个或多个成员，或者更新已存在成员的分数\n5. `ZCARD key `获取有序集合的成员数\n6. `ZCOUNT key min max `计算在有序集合中指定区间分数的成员数\n7. `ZINCRBY key increment member `有序集合中对指定成员的分数加上增量 increment\n8. `ZINTERSTORE destination numkeys key [key ...] `计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中\n9. `ZLEXCOUNT key min max `在有序集合中计算指定字典区间内成员数量\n10. `ZRANGE key start stop [WITHSCORES] `通过索引区间返回有序集合成指定区间内的成员\n11. `ZRANGEBYLEX key min max [LIMIT offset count] ` 通过字典区间返回有序集合的成员\n12. `ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] `通过分数返回有序集合指定区间内的成员\n13. `ZRANK key member `返回有序集合中指定成员的索引\n14. `ZREM key member [member ...] `移除有序集合中的一个或多个成员\n15. `ZREMRANGEBYLEX key min max `移除有序集合中给定的字典区间的所有成员\n16. `ZREMRANGEBYRANK key start stop `移除有序集合中给定的排名区间的所有成员\n17. `ZREMRANGEBYSCORE key min max `移除有序集合中给定的分数区间的所有成员\n18. `ZREVRANGE key start stop [WITHSCORES] `返回有序集中指定区间内的成员，通过索引，分数从高到底\n19. `ZREVRANGEBYSCORE key max min [WITHSCORES] `返回有序集中指定分数区间内的成员，分数从高到低排序\n20. `ZREVRANK key member `返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序\n+ 哈希(`Hash`)\n1. Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象,支持保存一个对象里面的多个字段以及对应的字段值\n2. `HSET key field value`将哈希表 key 中的字段 field 的值设为 value \n3. `HMSET key field1 value1 [field2 value2 ] `同时将多个 field-value (域-值)对设置到哈希表 key 中\n4. `HSETNX key field value `只有在字段 field 不存在时，设置哈希表字段的值.\n5. `HGET key field `获取存储在哈希表中指定字段的值\n6. `HGETALL key `获取在哈希表中指定 key 的所有字段和值\n7. `HVALS key `获取哈希表中所有值\n8. `HSCAN key cursor [MATCH pattern] [COUNT count] `迭代哈希表中的键值对\n4. `HKEYS key `获取所有哈希表中的字段\n5. `HLEN key `获取哈希表中字段的数量\n6. `HMGET key field1 [field2] `获取所有给定字段的值\n7. `HINCRBY key field increment ` 为哈希表 key 中的指定字段的整数值加上增量 increment \n8. `HINCRBYFLOAT key field increment `为哈希表 key 中的指定字段的浮点数值加上增量 increment \n9. `HEXISTS key field `查看哈希表 key 中，指定的字段是否存在,如果要检测key是否存在，可以使用通用命令来确认。\n10. `HDEL key field1 [field2]`删除一个或多个哈希表字段\n\n##### 参考\n+ 本文仅仅列出常用的几条Redis指令，具体指令描述，请参照[官方文档](https://redis.io/commands)","tags":["Redis"]},{"title":"leetcode Reserve Integer","url":"/archives/98ee2edb.html","content":"\n+ [Reserve Integer](https://leetcode.com/problems/reverse-integer/description/)\n```\nGiven a 32-bit signed integer, reverse digits of an integer.\n\nExample 1:\n\nInput: 123\nOutput: 321\nExample 2:\n\nInput: -123\nOutput: -321\nExample 3:\n\nInput: 120\nOutput: 21\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n\n```\n\n+ Solution\n```\npublic class ReverseInteger {\n\n\n    public static void main(String[] args) {\n        int x = 12320;\n        System.out.println(\"x:\" + x);\n        System.out.println(\"ReverseInt:\" + reserveFastest(x));\n    }\n\n    public static int ReverseInt(int x) {\n        double result = 0;\n        if (0 == x) return 0;\n        if (x > Integer.MAX_VALUE || x < Integer.MIN_VALUE) return 0;\n        int sign = (x > 0) ? 1 : -1;\n        x = x * sign;\n        int division = x;\n        int numLength = String.valueOf(x).length();\n        for (int i = 1; i <= numLength; i++) {\n            int currentDiv = 10;\n            double currentMul = (int) Math.pow(10, numLength - i);\n            int currentPlace = division % currentDiv;\n            division = division / currentDiv;\n            result = result + currentPlace * currentMul;\n            if (result >= Integer.MAX_VALUE || result <= Integer.MIN_VALUE) return 0;\n        }\n        return (int) (result * sign);\n    }\n\n    public static int reverseFast(int x) {\n        double result = 0;\n        while (x != 0) {\n            result *= 10;\n            result += x % 10;\n            x /= 10;\n        }\n        return result >= Integer.MAX_VALUE || result <= Integer.MIN_VALUE ? 0 : (int) result;\n\n    }\n\n    public static int reverseFaster(int x) {\n        long res = 0;\n        while (x != 0) {\n            res *= 10;\n            res += x % 10;\n            x /= 10;\n        }\n        return res == (int) res ? (int) res : 0;\n    }\n\n    public static int reserveFastest(int x) {\n        int res = 0;\n        while (x != 0) {\n            int tail = x % 10;\n            int newRes =  (res * 10 + tail);\n            if (res != (newRes - tail) / 10) return 0;\n            res = newRes;\n            x /= 10;\n        }\n        return res;\n    }\n}\n\n```\n","tags":["leetcode"]},{"title":"Object 类中toString()、equal()、hashCode()之间关系","url":"/archives/bd43d2da.html","content":"\n#### 未重写，从源码中区分\n\n1.  `toString()`\n+ toString()方法返回的是一个对象的字符串,\n+ 这个字符串的组成格式由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成(`getClass().getName() + \"@\" + Integer.toHexString(hashCode())`),源码如下\n```\npublic String toString() {\n        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n    }\n```\n2.  `equals()`\n+ `equals()`:针对两个非空引用值x和y，当前仅当x和y引用同一个对象时，两个对象才相等，即返回true。因为不是引用同一个对象，两个引用值在堆中创建了两个对象存储地址。\n3.  `hashCode()`\n+ `hashCode()`:由Object类定义的hashCode()方法确实会针对不同的对象返回不同的整数值，通过对象的内部地址转换来实现。主要通过区分返回的散列值不同，而区分每个对象。主要用于散列集合容器中，在往散列集合插入一个对象的时候，通过管理对象的散列值，检测每个对象的hashCode散列值，如果集合中已经存在该对象的散列值，则说明对象已经存在，反之。\n+ 而Object类只有`hashCode()`方法的定义，但是没有具体的实现，而具体的实现会针对不同的类中，分别有不同的实现。如：String的`hashCode()`源码实现如下： (至于String的hashCode实现机制中为什么要使用31？这个真能保证对象散列值的唯一性吗？这个问题尚未深究)\n```\n public int hashCode() {\n\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n    }\nhash的定义：\n /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n/** The value is used for character storage. */\n    private final char value[];\n```\n\n#### 重写之后，根据重写规则区分\n1. `toString()`方法重写之后，一般返回更加直观的数据，返回对象的属性与相关值组成的字符串拼接\n2.  `equal()`方法重写之后，一般只要自定义为两个对象的所有属性值相等就返回true\n3. `hashCode()`重写也可以根据自定义算法返回所需的整型值\n+ 所以对象相等，hashCode一定相等\n+ hashCode返回值相等，则对象未必相等，而即使对象不相等，也有可能返回相等的哈希散列码，这个根据具体的重写规则决定\n\n#### 判断两个对象相等的条件：\n1. 如果没有重写，只要hashCode不相等，则两个对象一定不相等\n2. 如果重写了，首先判断hashCode，如果不相等，那么这两个对象不相等(针对上述hashCode方法重写规则)，如果hashCode一样，再比较equals，如果两个条件都相等，那么这两个对象相等。\n\n#### Tips\n+ `finalize()`：当垃圾回收器确定该对象不存在更多的引用值的时候，由对象的垃圾回收器调用次方法，进行系统资源的重新配置与清除。可以在子类中重写`finalize`方法，进行手动垃圾回收。但是，一般情况下，不建议重写`finalize()`方法（并在其中实现任何功能逻辑），请相信`JVM`的`GC`。\n","tags":["Java"]},{"title":"Java异常总结","url":"/archives/7416d96f.html","content":"\n#### Java异常类结构图\n+ Java.lang.Throwable\n    + Java.lang.Error\n        + Java.lang.OutOfMemoryError\n        + ...\n    + Java.lang.Exception\n        + (`RuntimeException`):\n            + Java.lang.ArithmeticException\n            + Java.lang.IndexOutOfBoundsException\n            + Java.lang.NullPointerException\n            + Java.lang.ArrayStoreExcetpion\n            + Java.lang.ClassCastException\n            + ...\n        + (`checkedException`):\n            + Java.lang.IOException\n            + Java.lang.ClassNotFoundException\n            + Java.lang.SQLException\n            + Java.lang.CloneNotSupportException\n            + ...\n\n#### Throwable\n+ Throwable是所有异常和错误的根(超类)\n\n#### Error\n+ 代表编译时间和系统错误，程序发生的不可控或者不可处理的错误\n+ 发送错误的时候，最好的做法是立刻终止程序的执行，而且Error以及子类的错误都不用捕获抛出\n+ Error由Java虚拟机生成并抛出，包括动态链接失败，虚拟机错误等。程序对其不做处理。\n\n#### Exception\n+ 一般将Exception异常分配两类：Checked异常和Runtime异常\n##### Checked异常\n+ Checked异常是指可以被处理的异常，程序中需要手动显式处理Checked异常，否则会导致在编译期就发生异常而无法编译。\n+ 处理Checked类异常一般有两种方法：\n    1.  确定已知的异常之后，采用`try...catch`的方式捕获可能出现的异常\n    2.  也可以在方法定义的时候，在后面加上`throws exceptionName`的方式来抛出异常\n##### Runtime异常\n+ 也指非检查异常，例如除数是0或者数组越界的异常，产生频繁，如果处理会降低效率，所以这类异常交由系统自动检测并将他们交给缺省的异常处理程序\n+ 注意：这类异常并非不可以捕获，如果必须，也可以捕获处理\n\n#### Java 异常处理的误区和经验总结\n+ 对于异常捕获的finally区域，应该尽量避免在 finally 块中抛异常或者包含 return 语句。否则会影响try或者catch部分程序的运行，因为在 finally 块中抛出的任何异常都会覆盖掉在其前面由 try 或者 catch 块抛出异常。包含 return 语句的情形相似,实例代码在gist中。\n    1. try-catch 块与 finally 块同时抛异常--> [try-catch 块与 finally 块同时抛异常](https://gist.github.com/liangqian/0bcaa6d3b775d24cf53e20ac651935df)\n    2. try-catch 块与 finally 块同时包含 return 语句-->[try-catch 块与 finally 块同时包含 return 语句](https://gist.github.com/liangqian/b63f6a658a0ed04f81caf2ddd0cb7263)\n+ 参考：[Java 异常处理的误区和经验总结\n](https://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/)\n","tags":["Java","Exception"]},{"title":"自己对Java堆和栈的理解","url":"/archives/199ee4b3.html","content":"\n#### 预备知识：线程和进程\n+ 进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是进行资源分配和调度的一个独立单位\n+ 线程：线程是进程的一个实体，是CPU进行调度和分派的基本单位，是比进程更小的能独立运行的基本单位，但是线程不能独立运行，需要在应用程序中控制执行\n    + 线程基本自己不拥有系统资源，只拥有一点在运行中必不可少的资源(程序计数器，一组寄存器和栈)，但是它可以和进程下的其他的线程共享该进程所有的资源\n    + 一个线程可以创建和撤销其他线程，同一个进程中可以并发执行多个线程(多线程)\n\n#### 操作系统角度中的堆和栈\n+ 堆是应用程序在运行的时候，请求操作系统分配的内存空间，运行过程中也可以向系统申请额外的空间，但是用完之后，需要进行回收，不然就会导致内存泄漏\n+ 栈是线程独有的内存空间，保存其运行状态和局部自动变量。栈在线程初始化的时候创建，每个栈都是相互独立，因此栈是线程安全。操作系统在切换线程的时候会自动切换栈。\n\n#### Java中的堆和栈\n+ 内存分配策略：程序运行的内存分配策略有三种，分别是静态的，栈式的，堆式的。\n    1. 静态存储分配：在编译期就能确定每个数据目标在运行时所需要的存储空间需求，因而在编译时就能给他们分配所需的内存空间。这种策略要求在程序代码中不允许有可变数据结构，不允许有嵌套和递归的结构出现，否则会导致编译程序无法准备计算存储空间需求\n    2. 栈式存储分配(动态)：和静态分配策略相反，程序在对数据区的需求在编译期无法预知，而在运行时能够确定的内存分配使用栈式存储分配策略。但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存。和数据结构的栈一样，按照先进后出的原则进行分配\n    3. 堆式存储分配：堆式存储分配策略是以上两个分配策略的补充，静态存储分配要求在编译期就能知道所有变量的存储需求，栈式存储要求在运行进入程序入口时就必须知道变量的存储要求，而堆式则专门针对静态存储分配策略和栈式存储分配策略无法确定存储要求的数据结构进行内存分配，比如可变长度串，或者对象实例。堆由大片的可利用块或者空闲块组成，堆中的内存可以按照任意的顺序分配和释放\n+ Java中的堆和栈\n    + Java把内存划分为两类：栈内存、堆内存\n    + 栈内存：在函数中定义的一些基本类型的变量和对象的引用都由栈内存进行分配内存空间，当分配的空间超过了变量的作用域之后，java会释放该变量分配的内存空间。\n    + 堆内存：主要用于存储new创建的对象和数组。在堆中创建的数组或者对象还可以在栈中创建一个特性变量，让这个变量的取值指向堆中某个对象或者数组在堆中的内存首地址，栈中的这个变量就成了堆中对象或者数组 的引用变量。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。\n+ Java中堆和栈的对比\n    1. Java的堆是一个运行时数据区，优势是可以动态分配内存大小，生存期也不必事先告诉编译器，因为是在运行时动态分配内存的，事后Java的垃圾回收机制也会回收那些不使用的内存数据，但缺点是，由于要在运行时动态分配内存，存取速度较慢。 \n    2. 栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int, short, long, byte, float, double, boolean, char)和对象句柄。 \n栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：\n<center>`int a = 2`</center>\n<center>`int b = 2`</center>\n编译器先处理`int a = 2`，首先在栈中创建一个变量为a的引用，然后在栈中查找是否有值为2的数据块，如果已经有值为2 的数据块，则直接将变量a的引用指向值为2 的数据块，否则将数据2存入新建的数据块，并将a指向2。同理，对处理`int b = 2`语句的时候，也会经过必要的检测，检测栈中是否已经存在值为2的数据块。这样就出现了变量a、b同时指向2的情况。而再令`a=4`，修改a的值的时候，会重新在栈中检查\\创建值为4的数据块，再将a重新指向4.因此，在这种数据共享的前提下，一个变量数值改变，不会影响都另一个变量的数值。\n注意：这种数据的共享和两个对象的引用同时指向一个对象的这种共享不同，因为一个对象的变量修改，则直接修改变对象的内部状态，会影响到另一个对象的引用变量。","tags":["Java","TakeDown","JVM"]},{"title":"Spring事务管理","url":"/archives/762945f0.html","content":"\n\n#### 什么是事务：\n+ 事务是指逻辑上的一组操作，这组操作要么成功，要么失败\n\n+ 事务的四大特性：\n    + 原子性：指的是事务中不可分割的工作单位，事务中的操作，要么都发生，要么都不发生\n    + 隔离性：多个用户并发访问数据库的时候，一个用户的事务不能被其他用户的事务干扰，多个并发事务之间的数据要互相隔离。\n    + 一致性：事务执行的前后数据的完整性必须一致\n    + 持久性：一个事务一旦被提交，它对数据库中的修改是永久的，即使数据库故障也不会产生影响\n\n#### Spring事务管理高层抽象的三个接口\n1. 事务管理器(PlatformTransactionManager):主要进行事务管理，而后面的定义信息，运行状态是协助管理的字段或者方法. PlatformTransactionManager单纯是一个接口类，具体的实现类会细分到不同的事务管理实现类\n2. 事务定义信息(TransactionDefinition):隔离、传播、超时、只读\n3. 事务具体运行状态(TransactionStatus)\n\n+ 安全性问题\n    + 脏读：一个事务读取了另一个事务改写但未提交的数据，如果这些数据被回滚，则读取到的数据无效\n    + 不可重复读：在同一个事务中，多次读取同一数据返回的结果有所不同\n    + 幻读：一个事务读取了几行数据之后，另一个事务插入几行，幻读就发生了。再后来的查询中，第一个事务就会发现一些原来没有的数据记录\n\n+ `TransactionDefinition`事务隔离级别：\n    1. READ_UNCOMITED:允许你读取还没提交的改变了的数据，可能会出现脏，幻，不可重复读\n    2. READ_COMITED:允许在并发事务已经提交后读取。可防止脏读，但是幻读和不可重复读还会发生\n    3. REPEATABLE_READ:对相同字段的多次读取是一致的，除非数据被事务本身改变。可防止脏读、不可重复读，但幻读仍然可能发生\n    4. SERIALIABLE:完全服从ACID的隔离级别，确保不发生脏读，幻读和不可重复读。它是在所有的隔离级别中最慢的，他是典型的通过完全锁定在事务中涉及的数据表来完成\n+ `TransactionDefinition`事务的传播行为:主要是为了解决业务层之间的方法(本来就有独自的事务)调用的问题\n    1. PROPAGATION_REQUIRED:支持当前的事务，如果不存在，则新建事务\n    2. PROPAGATION_SUPPORTS:支持当前事务，如果不存在，则不使用事务\n    3. PROPAGATION_MANATORY:支持当前事务，如果不存在，则抛出异常\n    4. PROPAGATION_REQUIRE_NEW:如果当前有事务，则挂起，创建一个新的事务\n    5. ROPAGATION_NOT_SUPPORTED:以非事务方式运行，如果有事务，则挂起当前事务\n    6. ROPAGATION_NEVER：以非事务的方式运行，如果有事务，则抛出异常\n    7. ROPAGATION_NESTED：如果当前事务存在，则使用嵌套事务执行\n    8. 分类归纳：1*、2、3可以归为一类，保持互相调用的方法的事务一致；4*、5、6归为一类，保持两个方法操作不在一个事务中；7为嵌套事务，一个方法执行完成，设置保存点，如果后续方法出现异常，则返回到保存点或者起点等\n\n\n#### Spring 支持两种类型的事务管理\n+ 编程试事务管理(代码中使用TransactionTemplate，具有灵活性却难以维护)\n    1. 在需要使用的service类中使用TransactionTemplate\n    2. TransactionTemplate依赖DataSourceTransactionManager\n    3. DataSourceTransactionManager依赖DataSource构造\n    4. 在类中用代码进行事务管理：\n```\npublic void transfer(final String out,final String in,final Double money) {\n\n       transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n           @Override\n           protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {\n               accountDao.outMoney(out,money);\n               int i = 1 / 0;    //throw execption then broken\n               accountDao.inMoney(in,money);\n           }\n       });\n    }\n```\n+ 声明式事务管理(基于AOP配置XML的方式实现，从业务代码中分离出事务管理)\n    1. 基于TransactionProxyFactory的方式：通过增强需要进行事务管理的目标类，将被代理过的service注入代替原来的目标接口，进行调用即可产生事务管理效果。但这种实现方式如果需要进行事务管理的类太多，则操作会繁琐。XML的bean类配置如下：\n```\n<!--配置业务层的代理-->\n    <bean id=\"accountProxyService\" class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\">\n        <!--配置代理增强的目标对象-->\n        <property name=\"target\" ref=\"accountService\"/>\n        <!--注入事务管理器-->\n        <property name=\"transactionManager\" ref=\"transactionManager\"/>\n        <!--注入事务属性-->\n        <property name=\"transactionAttributes\">\n            <props>\n                <!--\n                prop的格式:\n                    PROPAGATION :事务的传播属性\n                    ISOLATION    :事务的隔离级别\n                    readOnly     : 只读（不可以发生修改，插入，删除等操作）\n                    -Exception   :发生哪些异常回滚事务\n                    +Exception   :发生哪些异常不回滚\n                -->\n                <prop key=\"transfer\">PROPAGATION_REQUIRED,+java.lang.ArithmeticException</prop>\n            </props>\n        </property>\n    </bean>\n```\n    2. 基于AspectJ的XML方式： 通过AOP进行切点上异常监控来进行事务管理。可以借助AOP的横向切入点的方式来进行所有的业务层代码的事务管理,而且业务层代码也不会出现设计事务管理的相关代码。配置如下：\n```\n<!--声明式事务管理的配置：配置事务通知(配置增强)-->\n    <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        <tx:attributes>\n            <!--监控方法支持通配符配置-->\n            <!--\n                propagation      :事务传播行为\n                isolation        :事务隔离级别\n                read-only        :只读\n                rollback-for     :发生哪些异常回滚\n                no-rollback-for  :发生哪些异常不回滚\n                timeout          :超时信息\n            -->\n            <tx:method name=\"transfer*\" propagation=\"REQUIRED\"  />\n        </tx:attributes>\n    </tx:advice>\n\n    <!--配置AOP切面-->\n    <aop:config>\n        <!--配置切入点-->\n        <aop:pointcut id=\"pointCut1\" expression=\"execution(* info.cloversoulmate.service.AccountService+.*(..))\"/>\n        <!--配置切面-->\n        <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointCut1\"/>\n    </aop:config>\n```\n\n    3. 基于注解形式的事务管理：在目标业务类中注解生效，实现事务管理。\n    + 配置文件中开启事务管理器的注解事务：\n\n```\n    <!--给事务管理器开启注解事务-->\n    <tx:annotation-driven transaction-manager=\"transactionManager\"/>\n```\n\n   + 在类的头部加上注解，并配置相关属性\n\n```\n/**\n * 注解中的属性根据需求情况配置在注解括号里面，如果不配置注解属性，会按照默认方式进行\n * propagation  :事务传播行为\n * isolation    ：事务隔离级别\n * readOnly     ：只读\n * rollbackFor  ：发生哪些异常回滚\n * noRollbackFor：发生哪些异常不回滚\n * */\n@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.DEFAULT,readOnly=false)\npublic class AccountServiceImpl implements AccountService {\n\n```\n\n","tags":["Java","Spring"]},{"title":"抽象类和接口的区别","url":"/archives/3e6ff0a8.html","content":"+ 一个实现类只能继承一个抽象类，但可以实现多个接口\n+ 抽象类可以有构造函数，接口没有构造函数\n+ 抽象类可以有普通的成员变量，接口没有普通的成员变量\n+ 抽象类中可以没有抽象方法，有带方法体的普通方法，接口中都是抽象方法(默认抽象，不用加abstract关键字)\n+ 抽象类可以有静态方法，静态代码块；但是接口中不能有静态方法\\代码块\n+ 抽象类中方法的权限修饰符可以是public、protected、default；接口只能是public\n+ 抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认)\n","tags":["Java"]},{"title":"iptables防火墙及其命令","url":"/archives/6c6825f6.html","content":"\n#### 概述：\n+ iptables命令是Linux上常用的防火墙软件，是netfilter项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。 \n+ iptables防火墙可以用于创建过滤(filter)与NAT规则。所有Linux发行版都能使用iptables，因此理解如何配置iptables将会帮助你更有效地管理Linux防火墙。\n\n#### 使用规则\n+ 语法\n    +   `iptables (选项) (参数)`\n    + `iptables -t 表名 <-A/I/D/R> 规则链名 [规则号] <-i/o 网卡名> -p 协议名 <-s 源IP/源子网> --sport 源端口 <-d目标IP/目标子网> --dport 目标端口 -j 动作`\n\n+ 选项\n```\n-t<表>：指定要操纵的表； \n-A：向规则链中添加条目； \n-D：从规则链中删除条目； \n-i：向规则链中插入条目； \n-R：替换规则链中的条目； \n-L：显示规则链中已有的条目； \n-F：清楚规则链中已有的条目； \n-Z：清空规则链中的数据包计算器和字节计数器； \n-N：创建新的用户自定义规则链； \n-P：定义规则链中的默认目标； \n-h：显示帮助信息； \n-p：指定要匹配的数据包协议类型； \n-s：指定要匹配的数据包源ip地址；\n-j<目标>：指定要跳转的目标； \n-i<网络接口>：指定数据包进入本机的网络接口； \n-o<网络接口>：指定数据包要离开本机所使用的网络接口。\n```\n\n+ 表名(4个)：\n    + filter：包过滤，用于防火墙规则\n    + mangle：数据表修改(Qos),用于实现服务质量\n    + nat：用于NAT功能(端口映射，地址映射等)\n    + raw：优先级最高，设置raw时一般是为了不再让iptables做数据包的链接跟踪处理，提高性能\n+ 表在数据进入服务器到输出的流程\n<center>![数据传输](http://aliosw.oss-cn-hangzhou.aliyuncs.com/iptables%E8%A1%A8%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%8C%85%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8.gif)\n</center>\n+ 规则链(5个)：\n    + `PREROUTING`链：数据包进入路由表之前\n    + `INPUT`链：处理输入数据包，通过路由表目的地为本机\n    + `FORWARD`链：通过路由表之后，目的地不是本机\n    + `OUTPUT`链：处理输出数据包，由本机产生，向外转发\n    + `POSTROUTING`链：发送到网卡接口之前\n+ 表与规则链的对应关系\n<center>\n![表与规则链的对应关系](http://aliosw.oss-cn-hangzhou.aliyuncs.com/iptables%E8%A1%A8%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%8C%85%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8.gif)\n</center>\n+ 动作：\n    +   ACCEPT：接收数据包\n    +   DROP：丢弃数据包\n    +   REDIRECT：重定向，映射，透明代理\n    +   SNAT：源地址转换\n    +   DNAT：目的地址转换\n    +   MASQUERADE：IP伪装\n","tags":["Linux"]},{"title":"Mybatis 修饰符`#{}`和`${}`的区别","url":"/archives/1db25542.html","content":"\n## Mybatis 修饰符`#{}`和`${}`的区别是什么\n+ mybatis 中使用 sqlMap 进行 sql 查询时，经常需要动态传递参数，mybatis提供了两种传输数据的修饰方式：`#{}`和`${}`\n\n#### #{}方式\n+ `#{}`将传入的数据当作是一个字符串，对传入的数据加上双引号\n+ 如：`where id = #{userId}`，如果传入10，则解析sql的时候解析成 `wherer id = '10'`\n\n#### ${}方式\n+ `${}`传入的数据会直接显示生成在sql中，没有任何修饰符，直接替换成变量的值\n+ 如：`where id = #{userId}`，如果传入10，则解析sql的时候解析成 `wherer id = 10`\n\n#### 对比\n+ 动态解析阶段的区别：mybatis在对sql语句进行预编译之前，会对sql进行动态解析，解析为一个Boundsql对象，也是在此对动态sql进行处理。对于sql语句(`select * from user where name = #{name}\\${name};\n`)解析表现如下：\n    1. `#{}`解析为一个jdbc预编译语句(`prepared statement`)的参数标记符(`?`)；如：`select * from user where name = ?;`\n    2. `${}`在解析的时候，仅仅为一个存粹的字符串替换，在动态sql解析阶段会进行变量替换；当上面例子中的sql传入参数(`qscom`)的时候，sql被解析为：`select * from user where name = qscom;`\n+ 安全性：根据sql注入的原理，`#{}`在传入数据中加上双引号修饰符，能一定程度上降低sql注入的风险，而`${}`对传入的数据没有任何的修饰隔离，完全无法避免sql注入\n+ 使用习惯：`${}`方式一般用户传入动态的数据库名，表名称、列名称等；`#{}`一般用于具体数据筛选匹配\n+ 实际生产中，除了安全性原因，能避免使用`${}`方式传数据就避免之外，从性能上，`#{}`解析的相同的预编译sql可以重复利用","tags":["Mybatis"]},{"title":"JDBC SQL预编译","url":"/archives/8bdd2473.html","content":"\n## JDBC SQL预编译\n\n####  定义\n+ SQL预编译是指数据库驱动在发送sql语句和参数给DBMS之前对SQL语句进行编译，这样DBMS在执行SQL时，就不需要重新编译。\n#### 为什么要预编译？\n+ JDBC使用`PreparedStatement `对象来进行预编译语句\n    1. 预编译可以优化sql的执行：预编译之后的sql多数情况下可以直接执行，DBMS不需要再次编译；对于越复杂的SQL，编译的成本和复杂度就越高，而预编译可以将多次重复操作，合并多次操作为一次操作\n    2. 预编译语句可以重复利用：把SQL预编译之后的对象(PreparedStatement )缓存下来，下次对于同一个sql，直接可以使用这个缓存的对象执行，不需要重复\n","tags":["Mysql"]},{"title":"Mybatis 如何获取保存对象之后生成的自增主键?","url":"/archives/efb286cc.html","content":"\n## Mybatis 使用Insert保存对象，如何获取保存对象之后生成的自增主键?\n\n1.  配置sqlmap：在insert的sqlmap中配置生成自动生成主键参数，并配置对应的主键字段名称\n```\n<insert id=”insertname” usegeneratedkeys=”true” keyproperty=”id”> \n     insert into names (name) values (#{name}) \n    </insert>\n```\n2.  在Java代码中调用Mapper方法保存了目标对象，主键数值会映射到对象中\n```\n    name name = new name(); \n    name.setname(“qscom”); \n    int rows = mapper.insertname(name); \n    system.out.println(\"rows inserted = \" + rows); //返回执行操作的行数\n    system.out.println(\"generated key value = \" + name.getid());//打印生产的自增ID数值\n```\n","tags":["Mybatis"]},{"title":"多线程基本概念","url":"/archives/7ccdc859.html","content":"####  线程和进程的区别\n+ 多个进程的内部数据和状态都是完全独立的，而多线程是共享一块内存空间和一组系统资源，有可能会互相产生影响。\n+ 线程本身的数据通常只有寄存器数据，而程序执行时使用堆栈，所以线程的切换比进程的切换负担成本要小。\n+ 线程的目的是“最大限度地利用CPU资源”，当某个线程的处理不需要占用CPU而只需要和IO打交道的时候，让需要占用CPU资源的其他线程有机会获得CPU资源。\n\n#### 多线程实现\n+ 实现方式有两种，一种是继承Thread类来实现run()方法，在run()方法中实现需要进行的多线程任务，第二种是实现Runable接口，重写run()方法处理多线程任务。这两种方法都是需要通过start()方法启动线程，然后让start()方法准备好系统资源，再去调用并执行run()方法完成线程任务。\n+ 源码上，Thread也是在实现了Runable接口的基础上实现了Runable的run()方法\n+ 两种实现方法根据实际情况选择，如果该类已经继承了其他方法(单继承性)，只能通过实现Runable接口来进程多线程任务处理。\n\n#### 线程的生命周期\n+ 如图：\n<center>\n![线程的生命周期](http://aliosw.oss-cn-hangzhou.aliyuncs.com/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)\n</center>\n+ 线程的生命周期分为五个阶段：创建状态、就绪状态、运行状态、阻塞状态、消亡状态。系统需要将多个线程在这五个状态之间切换来实现最大限度的运用系统资源\n<center>\n![线程状态转换图](http://aliosw.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)\n</center>\n    1.  新建状态：当程序使用`new`关键字创建一个线程之后，该线程就处于新建状态，此时仅由JVM分配内存，并初始化其成员变量的值\n    2.  就绪状态：当线程对象调用`start()`方法之后，该线程就处于就绪状态。Java虚拟机会为其创建方法，调用栈和程序计数器，等待线程调度器调度运行\n    3.  运行状态：如果处于就绪状态的线程获得了CPU资源，开始执行`run()`方法的线程执行体，则该线程处于运行状态\n    4.  阻塞状态：当运行中的线程失去了CPU资源之后，便进入了阻塞状态。如果需要从阻塞状态进入就绪状态，需要等待线程调度器调度分配才能返回到就绪状态\n        + 线程进入阻塞状态的条件\n            + 线程调用`sleep()`方法主动放弃CPU资源\n            + 线程调用了阻塞式的IO方法，在该方法返回之前，该线程处于被阻塞状态\n            + 线程在等待通知(`notify()`)\n            + 线程被调用`suspend()`方法进行挂起\n            + 线程试图获得同步监视器，但是监视器正在被其他线程使用中\n        + 解除阻塞状态线程：与导致阻塞的条件相反即可解除阻塞状态\n    5.  消亡状态：当线程对象的`run()`和`call()`方法执行完成，线程正常结束；如果线程抛出一个未捕获的`Execption`或者`Error`、直接调用该线程的`stop()`方法强行终止线程的时候，线程也会进入消亡状态，只不过这属于非正常方式结束。注意，强行执行`stop()`的方式来结束线程容易导致死锁，不推荐使用\n","tags":["Java","多线程"]},{"title":"多线程关键字volatile和synchronized区别","url":"/archives/bd778d6e.html","content":"\n#### `volatile`关键字\n+ 在JVM内存模型中，有主内存一说(main memory)，每个线程都有自己的memory(如寄存器)。为了性能，一个性能需要在自己的memory中保持要访问的变量副本。这样就会出现某个瞬间，线程memory数据尚未同步的时候，可能会出现每个线程内的变量副本数据不一致，或者与main memory不一致的问题。\n+ 用于多线程，同步变量。线程为了提高效率，将成员变量(A)拷贝了一份(B)，某些线程中对A的访问其实就是对B这个copy体的访问。在JVM管理下某个动作才会同步A与B，这就存在A与B的不一致的情况。`volatile`就是用来避免这情况。在JVM管理中，`volatile`所修饰的变量不保留拷贝，直接访问主内存(A)\n\n#### `synchronized`关键字(加锁)\n+ 多线程在共享同一片存储空间的同时，带来了方便，也带来了范围内的冲突的可能性，出现同一个数据同时被多个线程访问的情况。`synchronized`关键字可以解决这个问题，被`synchronized`修饰的方法或者代码块或者类，在同一个时间片内只能有一个访问者获得访问权限\n+ 之前也有一个笔记是写关于`synchronized`锁的描述：[synchronized](http://royleo.xyz/2016/10/14/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%9F%BA%E7%A1%80%E4%B9%8Bsynchronized%E5%90%8C%E6%AD%A5/)\n+ `synchronized`修饰的方法、代码块、类具有原子性\n+ Java的每个对象都有一个锁(Lock)或者叫做监视器，当访问某个对象的`synchronized`方法或者是代码块，都意味着将该对象上说，此时其他线程无法访问，直至到锁被释放。如果一个对象有多个带`synchronized`锁的方法，在其中一个锁未被释放之前，其他线程也无法访问改对象的任何带`synchronized`的方法。\n\n#### `synchronized`和`volatile`都具有同步线程间数据的能力\n+ `volatile`同步主内存和各个副本内存里面被`volatile`所修饰的变量的数据，保证被修饰的变量在所有线程中必须是同步的，不会出现数据冲突的情况，任何线程改变了数值，其他线程马上能获得最新的数据\n+ `synchronized`同样具备同步线程间数据的能力，先看`synchronized`同步数据的步骤：\n    1. 线程获得请求监控对象的对象锁(如果被锁，则等待锁被释放)\n    2. 线程内的旧数据被消除，从主内存中读取当前最新的数据\n    3. 执行`synchronized`内的代码\n    4. 将数据改变情况写入到主内存区域中\n    5. 释放监控对象的对象锁\n+ 被`synchronized`修饰的代码块或者方法都会等待执行完成才会释放锁权限，保证了其原子性\n\n#### `synchronized`和`volatile`比较\n+ `volatile`主要用于多个线程感知实例变量被更改的场合，从而使得各个线程获得最新数据。它强制线程每次从主内存中读取变量，保证了数据的可见性\n+ `volatile`只是轻量级，只能修饰变量；`synchronized`还可以修饰方法、代码块或者类对象\n+ `volatile`只能保证数据的可见性，不能用来同步，因为多个线程并发访问`volatile`修饰的变量不会阻塞\n+ `synchronized`不仅保证了可见性，还保证了数据的原子性\n\n\n\n\n","tags":["Java"]},{"title":"mysql连接查询","url":"/archives/466fafff.html","content":"### 连接的分类(功能性分类)\n+ 左连接：获取左表所有记录，如果右表没有匹配的数据，用null填充至与左表记录数持平；\n+ 右连接：获取右表所有记录，数据量以右表为主，填充方法与左连接相同；\n+ 内连接：获取两表中满足匹配关系的关联记录，不包括不存在的数据\n\n### 语法\n+ `select * from tableA left(right/inner) join tableB on tableA.ID compopr tableB.ID;`\n+ 说明：tableA/B 是两联合查询的表；compopr 是比较运算符(=,>,<,>=,<=,<>)\n\n### 实例\n\n##### 数据准备\n+ 两个数据表，表中有能管理数据的字段值，并且两表数据量不一致。\n+ 创建表：\n```\nCREATE TABLE a (aID int( 1 ) AUTO_INCREMENT PRIMARY KEY , aNum char( 20 ))\nCREATE TABLE b(bID int( 1 ) NOT NULL AUTO_INCREMENT PRIMARY KEY ,bName char( 20 ))\n```\n+ 数据准备：\n```\nINSERT INTO a VALUES ( 1, 'a20050111' ) , ( 2, 'a20050112' ) , ( 3, 'a20050113' ) , ( 4, 'a20050114' ) , ( 5, 'a20050115' ) ;\nINSERT INTO b VALUES ( 1, ' 2006032401' ) , ( 2, '2006032402' ) , ( 3, '2006032403' ) , ( 4, '2006032404' ) , ( 8, '2006032408' ) \n```\n\n##### 查询实验\n\n5. 左连接：`select * from a  left join b on a.aID=b.bID;`,查询结果如下；left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.\n<center>![左连接查询结果](http://aliosw.oss-cn-hangzhou.aliyuncs.com/l.png)</center>\n6. 右连接：`select * from a right join b on a.aID=b.bID;`,查询结果如下；和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充.\n<center>![右连接查询结果](http://aliosw.oss-cn-hangzhou.aliyuncs.com/r.png)\n</center>\n7. 内连接(相等连接)：`select * from a inner join b on a.aID=b.bID;`；从查询结果可以看出，检索见过中只有满足匹配条件的数据，不满足的数据不会出现在结果中\n<center>![内连接查询结果](http://aliosw.oss-cn-hangzhou.aliyuncs.com/i.png)</center>\n\n### 用法拓展\n+ 联合连接查询的时候，还可以增加where条件筛选语句，帮助更加精确查询定位数据\n\n\n","tags":["Mysql"]},{"title":"spring Bean学习Review","url":"/archives/70e4edda.html","content":"## spring Bean学习&Review\n#### 概述：\n+ 公司重构项目主要基于SpringBoot，发现用了这么久的Spring，却还没有认真的总结过Bean的使用以及一些需要注意的东西，这里回头总结一下下\n#### 关于Bean\n+ Bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象\n+ 配置元数据\n    + 基于XML的配置文件\n    + 基于注释的配置\n    + 基于Java的配置\n+ bean定义的下列属性：\n    + class :  强制性，指定用来创建的Bean类\n    + name : s 指定特定的bean 标识符\n    + scope :  指定由特定的 bean 定义创建的对象的作用域\n    + properties :  注入依赖关系\n    + initialization 方法 :  在 bean 的所有必需的属性被容器设置之后，调用回调方法。\n    + destruction 方法 :  当包含该 bean 的容器被销毁时，使用回调方法\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n   <!-- A simple bean definition -->\n   <bean id=\"...\" class=\"...\">\n       <!-- collaborators and configuration for this bean go here -->\n   </bean>\n\n   <!-- A bean definition with lazy init set on -->\n   <bean id=\"...\" class=\"...\" lazy-init=\"true\">\n       <!-- collaborators and configuration for this bean go here -->\n   </bean>\n\n   <!-- A bean definition with initialization method -->\n   <bean id=\"...\" class=\"...\" init-method=\"...\">\n       <!-- collaborators and configuration for this bean go here -->\n   </bean>\n\n   <!-- A bean definition with destruction method -->\n   <bean id=\"...\" class=\"...\" destroy-method=\"...\">\n       <!-- collaborators and configuration for this bean go here -->\n   </bean>\n\n   <!-- more bean definitions go here -->\n\n</beans>\n```\n___\n#### scope 作用域\n+ singleton ： 该作用域将 bean 的定义的限制在每一个 Spring IoC 容器中的一个单一实例(默认)。\n+ prototype ：该作用域将单一 bean 的定义限制在任意数量的对象实例。\n+ request ： 该作用域将 bean 的定义限制为 HTTP 请求。只在 web-aware Spring ApplicationContext 的上下文中有效。\n+ session ： 该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。\n+ global-session ： 该作用域将 bean 的定义限制为全局 HTTP 会话。只在 web-aware Spring ApplicationContext 的上下文中有效。\n___\n#### Bean 后置处理器\n+ 重写BeanPostProcessor接口\n+ BeanPostProcessor ：初始化 bean 的之前的处理逻辑\n+ BeanPostProcessor ：初始化 bean 之后实现更复杂的逻辑\n```\npackage com.tutorialspoint;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\nimport org.springframework.beans.BeansException;\npublic class InitHelloWorld implements BeanPostProcessor {\n   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n      System.out.println(\"BeforeInitialization : \" + beanName);\n      return bean;  // you can return any other object as well\n   }\n   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n      System.out.println(\"AfterInitialization : \" + beanName);\n      return bean;  // you can return any other object as well\n   }\n}\n```\n#### 继承\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n   <bean id=\"beanTeamplate\" abstract=\"true\">\n      <property name=\"message1\" value=\"Hello World!\"/>\n      <property name=\"message2\" value=\"Hello Second World!\"/>\n      <property name=\"message3\" value=\"Namaste India!\"/>\n   </bean>\n\n   <bean id=\"helloIndia\" class=\"com.tutorialspoint.HelloIndia\" parent=\"beanTeamplate\">\n      <property name=\"message1\" value=\"Hello India!\"/>\n      <property name=\"message3\" value=\"Namaste India!\"/>\n   </bean>\n\n</beans>\n```\n+ 父 bean 自身不能被实例化，因为它是不完整的，而且它也被明确地标记为抽象的。当一个定义是抽象的，它仅仅作为一个纯粹的模板 bean 定义来使用的，充当子定义的父定义使用\n___\n#### 注入内部Beans\n+ Inner beans 是在其他 bean 的范围内定义的 bean\n+ 在XML配置文件中将各个类之间的关系描述清楚\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n   <bean id=\"outerBean\" class=\"...\">\n      <property name=\"target\">\n         <bean id=\"innerBean\" class=\"...\"/>\n      </property>\n   </bean>\n</beans>\n```\n#### 注入集合\n+ 有时候需要引入多个值\n+ Spring 提供四种集合类型的配置元素：List、set、map、props\n|元素|描述| \n|---|---|\n|`<List>`|有助于连线，如 注入一列值，允许重复|\n|`<set>`|有助于连线一组值，但不允许重复|\n|`<map>`|可以用来注入键值对集合，其中，键，值可以是任何类型|\n|`<props>`|可以用来注入键值对集合，其中，键，值都是字符串类型|\n\n\n\n","tags":["Java","Spring"]},{"title":"Mybatis延迟加载","url":"/archives/3170f59.html","content":"## Mybatis延迟加载\n\n#### 概述：\n+ resultMap可以实现高级映射（使用association、collection实现一对一及一对多映射），association、collection具备延迟加载功能\n+ 先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快\n\n#### 延迟加载配置\n+ mybatis默认没有开启延迟加载，需要在SqlMapConfig.xml中setting配置\n+ 在mybatis核心配置文件中配置：\n\n|设置项|描述|允许值|默认值|\n|--|--|--|--|\n|`lazyLoadingEnabled`|全局性设置懒加载|`true`or`false`|`false`|\n|`aggressiveLazyLoading`|当设置为`true`时，懒加载的对象可能会被人任何懒加载属性全部加载,否则每个属性都按需加载|`true`or`false`|`true`|\n\n\n+ 在配置文件中配置:\n```\n<!--全局配置参数，需要时再配置-->\n<settings>\n    <!--打开延迟加载的开关-->\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    <!--将积极加载改为消极加载即按需要加载-->\n    <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\n</settings>\n```\n\n#### 情景设定\n+ 如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载\n+ 定义两个Mapper的方法对应的statement\n```\n<select id='findOrderUserLazyLoading' resultMap='OrdersUserLazyLoadingResultMap'>\n    select * from orders;\n</select>\n\n<select id='findUserById' parameterType='int' resultMap='User'>\n    select * from user where id = #{value};\n</select>\n```\n+ 通过resultMap的定义将延迟加载执行配置起来\n```\n<!-- 延迟加载的resultMap -->\n<resultMap type=\"cn.itcast.mybatis.po.Orders\" id=\"OrdersUserLazyLoadingResultMap\">\n<!--对订单信息进行映射配置 -->\n<id column=\"id\" property=\"id\"/>\n<result column=\"user_id\" property=\"userId\"/>\n<result column=\"number\" property=\"number\"/>\n<result column=\"createtime\" property=\"createtime\"/>\n<result column=\"note\" property=\"note\"/>\n<!-- 实现对用户信息进行延迟加载\nSELECT orders.*,\n(SELECT username FROM USER WHERE orders.user_id = user.id)username,\n(SELECT sex FROM USER WHERE orders.user_id = user.id)sex\nFROM orders\n-->\n<association property=\"user\" javaType=\"xyz.royleo.User\"\nselect=\"xyz.royleo.mapper.UserMapper.findUserById\" column=\"user_id\">\n<!-- 实现对用户信息进行延迟加载 -->\n</association>\n</resultMap>\n```\n+ 测试思路\n1. 执行上边mapper方法()findOrdersUserLazyLoading),内部去调用cn.itcast.mybatis.mapper.OrdersMapperCustom中的findOrdersUserLazyLoading只查询orders信息(单表)\n2. 在程序中去遍历上一步骤查询出的List<Orders>，当我们调用Orders中的getUser方法时，开始进行延迟加载\n3. 延迟加载，去调用UserMapper.xml中findUserbyId这个方法获取用户信息\n+ 如果不使用延迟加载呢？\n    + 不使用mybatis提供的association及collection中的延迟加载功能，如何实现延迟加载？\n    + 方法如下：\n        + 定义两个mapper方法\n        1. 查询订单列表\n        2. 根据id查询用户信息\n        + 实现思路：\n            + 先去查询第一个mapper方法，获取订单列表\n            + 在程序中（service），按需去调用第二个mapper方法去查询用户信息\n","tags":["Mybatis"]},{"title":"Java关键字与总结","url":"/archives/fc53cc9d.html","content":"\n## 关键字`final`与`static`总结\n\n#### `final`\n+ 概述：`final`有‘终态’，‘不可改变’之意，可以修饰非抽象类，非抽象成员方法和变量。但是有时候出于设计、效率和资源等方面的因素需要考虑阻止某些变量或者方法做出改变.\n+ `final`关键字主要用于修饰类，方法，变量或者参数上\n    1. `final`类：\n        2. 被`final`修饰的类，不能被继承，其中的成员方法不能被覆盖，默认都是`final`.\n        3. 所以，在设计一个类的时候，如果该类在后来不会再进行扩展，那可以使用`final`关键字来定义\n    4. `final`方法\n        5. 能把方法锁定，防止任何继承类修改它的意义和实现\n        6. 高效，编译器遇到调用`final`方法的时候会将其直接转入内嵌机制，提高执行效率\n    7. `final`参数：当`final`修饰函数的参数的时候，被修饰的参数可以被读取使用，但是不能改变参数的值\n    7. `final`变量(常量)\n        8. 用`final`修饰的变量标识常量，一旦复制，就无法改变\n        9. 在定义`final`变量的时候，什么的时候可以不赋值，但是在`final`变量被使用之前，必须要为其赋值才能被使用\n```\npublic class Test3 { \n        private final String S = \"final实例变量S\"; \n        private final int A = 100; \n        public final int B = 90; \n        public static final int C = 80; \n        private static final int D = 70; \n        public final int E; //final空白,必须在初始化对象的时候赋初值 \n        public Test3(int x) { \n                E = x; \n        } \n        public static void main(String[] args) { \n                Test3 t = new Test3(2); \n                //t.A=101;    //出错,final变量的值一旦给定就无法改变 \n                //t.B=91; //出错,final变量的值一旦给定就无法改变 \n                //t.C=81; //出错,final变量的值一旦给定就无法改变 \n                //t.D=71; //出错,final变量的值一旦给定就无法改变 \n                System.out.println(t.A); \n                System.out.println(t.B); \n                System.out.println(t.C); //不推荐用对象方式访问静态字段 \n                System.out.println(t.D); //不推荐用对象方式访问静态字段 \n                System.out.println(Test3.C); \n                System.out.println(Test3.D); \n                //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. \n                System.out.println(t.E); \n                Test3 t1 = new Test3(3); \n                System.out.println(t1.E); //final空白变量E依据对象的不同而不同 \n        } \n        private void test() { \n                System.out.println(new Test3(1).A); \n                System.out.println(Test3.C); \n                System.out.println(Test3.D); \n        } \n        public void test2() { \n                final int a;     //final空白,在需要的时候才赋值 \n                final int b = 4;    //局部常量--final用于局部变量的情形 \n                final int c;    //final空白,一直没有给赋值.    \n                a = 3; \n                //a=4;    出错,已经给赋过值了. \n                //b=2; 出错,已经给赋过值了. \n        } \n}\n```\n\n#### `static`\n+ 概述：`static`表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态`static`代码块，但是Java语言中没有全局变量的概念\n    + 被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象\n    + 用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量\n+ `static`主要用于修饰静态内部类，静态变量，静态方法，静态代码块\n    1. 静态内部类：它不能访问外部类的非静态成员\n    1.  `static`变量：\n        2.  变量分类：根据是否被`static`修饰，可将变量分类：静态变量和实例变量\n            3.  静态变量：在内存中只有一个拷贝，JVM只为其分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问，也可以通过实例对象访问(不推荐了)\n            4.  实例变量：每创建一个实例，就会为实例变量分配一次内存，而且可以在内存中存在多个实例变量，互不影响\n    5.  `static`方法\n        6.  静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！\n    7.  `static`代码块\n        8.  用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块\n        9.  如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次\n\n#### `final`与`static`配合使用\n+ 用`final`与`static`修饰的方法和变量具有`final`和`static`并集的效果，也可以理解为'全局变量'\n+ 被`final`与`static`修饰的变量，实例化之后不能再改变，但是对于容器类(ArrayList、HashMap)的实例变量，不可以改变容器变量的本身，但是容器中的对象可以修改。\n```\npublic class TestStaticFinal { \n        private static final String strStaticFinalVar = \"aaa\"; \n        private static String strStaticVar = null; \n        private final String strFinalVar = null; \n        private static final int intStaticFinalVar = 0; \n        private static final Integer integerStaticFinalVar = new Integer(8); \n        private static final ArrayList<String> alStaticFinalVar = new ArrayList<String>(); \n        private void test() { \n                System.out.println(\"-------------值处理前----------\\r\\n\"); \n                System.out.println(\"strStaticFinalVar=\" + strStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"strStaticVar=\" + strStaticVar + \"\\r\\n\"); \n                System.out.println(\"strFinalVar=\" + strFinalVar + \"\\r\\n\"); \n                System.out.println(\"intStaticFinalVar=\" + intStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"integerStaticFinalVar=\" + integerStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"alStaticFinalVar=\" + alStaticFinalVar + \"\\r\\n\"); \n                //strStaticFinalVar=\"不可改变\";        //错误，final表示终态,不可以改变变量本身. \n                strStaticVar = \"可改变\";                //正确，static表示类变量,值可以改变. \n                //strFinalVar=\"不可改变\";                    //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 \n                //intStaticFinalVar=2;                        //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 \n                //integerStaticFinalVar=new Integer(8);            //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 \n                alStaticFinalVar.add(\"aaa\");        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 \n                alStaticFinalVar.add(\"bbb\");        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 \n                System.out.println(\"-------------值处理后----------\\r\\n\"); \n                System.out.println(\"strStaticFinalVar=\" + strStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"strStaticVar=\" + strStaticVar + \"\\r\\n\"); \n                System.out.println(\"strFinalVar=\" + strFinalVar + \"\\r\\n\"); \n                System.out.println(\"intStaticFinalVar=\" + intStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"integerStaticFinalVar=\" + integerStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"alStaticFinalVar=\" + alStaticFinalVar + \"\\r\\n\"); \n        } \n        public static void main(String args[]) { \n                new TestStaticFinal().test(); \n        } \n}\n```","tags":["Java"]},{"title":"Map的排序(key排序/value排序)","url":"/archives/a5b55d42.html","content":"## Map的排序(key排序/value排序)\n\n#### 概述\n+ Map是键值对的集合接口，它的实现类主要包括：HashMap,TreeMap,Hashtable以及LinkedHashMap等\n+ Map的key默认排列方式是增序排列，区分大小写\n+ 我们可以借助`Collections.sort()`重载来实现排序\n+ \n#### 按照key排序\n```\npublic static void sortByKey(List<Map.Entry<String,Integer>> list){\n        Collections.sort(list, new Comparator<Map.Entry<String,Integer>>() {\n            public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {\n                return o2.getKey().toString().compareTo(o1.getKey());\n            }\n        });\n    }\n```\n#### 按照value排序\n```\npublic static void sortByValue(List<Map.Entry<String,Integer>> listInfo){\n        Collections.sort(listInfo, new Comparator<Map.Entry<String, Integer>>() {\n            public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {\n                return o2.getValue().compareTo(o1.getValue());\n            }\n        });\n    }\n```\n#### 完整Demo\n```\npublic class CollectionSort {\n    public static void main(String[] args) {\n        HashMap<String ,Integer> hashMap = new HashMap<String, Integer>();\n        hashMap.put(\"a\",105);\n        hashMap.put(\"M\",110);\n        hashMap.put(\"f\",100);\n        hashMap.put(\"l\",150);\n        hashMap.put(\"e\",90);\n        System.out.println(\"-------排序前-------\");\n        //这里将map.entrySet()转换成list\n        List<Map.Entry<String,Integer>> listInfo = new ArrayList<Map.Entry<String,Integer>>(hashMap.entrySet());\n        for (Map.Entry<String,Integer> map : listInfo){\n            System.out.println(map.getKey()+\"----\"+map.getValue());\n        }\n        sortByValue(listInfo);\n        System.out.println(\"-------排序后-------\");\n        for (Map.Entry<String,Integer> map : listInfo){\n            System.out.println(map.getKey()+\"----\"+map.getValue());\n        }\n    }\n    public static void sortByKey(List<Map.Entry<String,Integer>> list){\n        //然后通过比较器来实现排序\n        Collections.sort(list, new Comparator<Map.Entry<String,Integer>>() {\n            public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {\n                //降序排序\n                return o2.getKey().toString().compareTo(o1.getKey());\n            }\n        });\n    }\n    public static void sortByValue(List<Map.Entry<String,Integer>> listInfo){\n        Collections.sort(listInfo, new Comparator<Map.Entry<String, Integer>>() {\n            public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {\n                return o2.getValue().compareTo(o1.getValue());\n            }\n        });\n    }\n}\n```\n","tags":["Java"]},{"title":"Git操作快速上手(日常指令)","url":"/archives/89baa56d.html","content":"## Git快速上手使用\n\n#### 本文目的：\n+ 由于最近给公司搭建了一个基于GitLab的版本管理工具，而之前公司都是使用SVN管理代码，而且不少同事尚未有使用Git的经历，所以写了这个文档，一方面旨在让同事们能快速在Git上手工作，不需要在Git的学习曲线上爬坡，另一方面，学会了本文档的基本操作之后，文末还有详细学习Git操作以及原理的传送门。这些基本操作能满足一个开发者基本的需求，但是如果遇到分支冲突等错误，传送门里面也有详细解答\n\n#### 上手步骤\n+ 先安装`Git`客户端：[下载链接](https://git-scm.com/)\n+ 打开Git Bash环境(一般安装了Git之后，Git会配置好全局环境)\n+ 生成ssh-key(生成两个文件，在${user}/.ssh/  目录下面，没有pub结尾的是私钥，以pub结尾的是私钥):作为加密使用\n    + 先添加个人信息(需要作为更改的标识)：\n        + 添加用户名：`git config --global user.name \"Your Name\"`\n        + 添加邮箱：`git config --global user.email you@example.com`\n\n#### 基本操作\n1. 克隆：`git clone url` \n2. 添加更改：`git add filename`\n3. 为提交添加注释：`git commit -m \"注释的内容\"`\n4. 提交到主分支：`git push origin master`\n5. 将别人提交的代码从远程主分支同步到本地：`git pull origin master`\n6. 创建本地分支(创建完之后自动切换到到新建的分支上)：`git checlout -b \"分支的名称\"`\n7. 在新的分支提交更改，注释（同2，3步操作）\n8. 如果要将自己创建的分支提交到远程仓库，创建自己的分支，执行：`git push origin 分支的名称`,这样，远程分支也有了你的分支，别人也就可以拉去你的分支进行查看，或者更改你发分支，合并你的分支等....\n9. 同样，也可以在本地合并你创建的分支的到主分支：\n    10. 撤换回到本地主分支：`git checkout master`\n    11. 在主分支合并本地分支: `git merge 分支的名称`\n    12. 合并之后再将结果提交到远程主仓库\n\n\n---\n参考：\n[Git中文文档](https://git-scm.com/book/zh/)\n[Git教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000)\n","tags":["Git","Linux"]},{"title":"面向切面编程(AOP)实例解释","url":"/archives/4c8b706f.html","content":"## 面向切面编程(AOP)实例解释\n\n#### 概述：\n+ 闲暇之余，回头回顾了一下AOP的知识，下面是两个例子，一个是基于XML配置形式来定义AOP方面的，另一个例子是基于@Aspect注解来定义方面的，第二个实例是在第一个实例的基础上改动而实现的，所以为了避免代码，我将每个实例的重点代码push了出来，这两部分组合起来就是一个完整的Project 代码，而且，能够明白地将这两种什么方式区分并将两部分代码联系起来，那就理解了AOP的用法了。\n#### AOP实例(基于AOP的XML结构)\n+ 导入jar包(通过Maven导入)：其他需要用到的自行导入\n    + `org.springframework`--->`spring-aop`\n    + `org.springframework`--->`spring-core`\n    + `org.springframework`--->`spring-context`\n    + `org.aspectj`--->`aspectjrt`\n    + `aopalliance`--->`aopalliance`\n    + `cglib`--->`cglib-nodep`\n+ 配置XML文件：\n```\n<aop:config>\n  <aop:aspect id=\"log\" ref=\"logging\"> <!--声明切面-->\n     <aop:pointcut id=\"selectAll\" expression=\"execution(* xyz.royleo.*.*(..))\"/><!--声明切点-->\n     <aop:before method=\"beforeAdvice\" pointcut-ref=\"selectAll\"/><!--声明通知-->\n     <aop:after method=\"afterAdvice\" pointcut-ref=\"selectAll\"/>\n     <aop:after-returning method=\"afterReturningAdvice\" returning=\"retVal\" pointcut-ref=\"selectAll\"/>\n     <aop:after-throwing method=\"AfterThrowingAdvice\" throwing=\"ex\" pointcut-ref=\"selectAll\"/>\n  </aop:aspect>\n</aop:config>\n   <bean id=\"student\" class=\"xyz.royleo.Student\">\n          <property name=\"name\" value=\"royleo\"/>\n          <property name=\"age\" value=\"23\"/>\n   </bean>\n   <bean id=\"logging\" class=\"xyz.royleo.Logging\"/>\n```\n#### AOP实例(基于AOP的@Aspect)\n+ 说明，由于这两个说明是使用一个实例，所以基于XML配置部分就不放出POJO的代码，将POJO代码放在基于@Aspect注解示例部分\n+ 导入的jra包跟XML实例相同\n+ 配置：\n    + 在XML配置文件中启用注解：`<aop:aspectj-autoproxy/>`\n+ 在Logging中声明切面，切点，通知\n```\n@Aspect\npublic class Logging {\n    @Pointcut(\"execution(* xyz.royleo.*.*(..))\")\n    private void selectAll(){}\n\n    @Before(\"selectAll()\")\n    public void beforeAdvice(){\n        System.out.println(\"Going to setup student profile.**方法被调用之前通知**\");\n    }\n    @After(\"selectAll()\")\n    public void afterAdvice(){\n        System.out.println(\"xyz.royleo.Student profile has been setup.**方法被调用之后通知**\");\n    }\n    @AfterReturning(pointcut = \"selectAll()\",returning = \"retVal\")\n    public void afterReturningAdvice(Object retVal){\n        System.out.println(\"Returning:\" + retVal.toString() + \" **方法返回值时触发通知**\" );\n    }\n    @AfterThrowing(pointcut = \"selectAll()\",throwing = \"ex\")\n    public void AfterThrowingAdvice(IllegalArgumentException ex){\n        System.out.println(\"There has been an exception: \" + ex.toString() + \" **抛异常时触发通知(捕捉到指定异常)**\");\n    }\n}\n```\n+ bean.xml配置\n```\n<aop:aspectj-autoproxy/>\n<!-- Definition for student bean -->\n<bean id=\"student\" class=\"com.tutorialspoint.Student\">\n  <property name=\"name\"  value=\"Zara\" />\n  <property name=\"age\"  value=\"11\"/>      \n</bean>\n\n<!-- Definition for logging aspect -->\n<bean id=\"logging\" class=\"com.tutorialspoint.Logging\"/> \n```\n+ 入口：\n```\npublic class MainApp {\n   public static void main(String[] args) {\n      ApplicationContext context = \n             new ClassPathXmlApplicationContext(\"Beans.xml\");\n      Student student = (Student) context.getBean(\"student\");\n      student.getName();\n      student.getAge();     \n      student.printThrowException();\n   }\n}\n```\n","tags":["Java"]},{"title":"线程同步基础之使用锁实现同步","url":"/archives/86946e12.html","content":"## 线程同步基础之使用锁实现同步\n#### 概述\n+ 使用锁实现同步是通过重写Lock接口来实现，与synchronized相比，Lock接口允许实现更复杂的临界区结构(控制的获取和释放不在同一个块结构中)\n\n#### 死锁\n+ 定义：当两个或者多个线程被阻塞并且他们等待释放的锁永远都不会是释放，就会发生死锁\n\n#### 使用实例\n+ Lock接口引入`tryLock()`方法获取锁，如果锁已经被其他线程获取，那就返回false，并继续往下执行代码(不是执行临界区代码，而且相当于事物回滚的机制)\n+ 使用`lock()`方法获取对锁的控制，必须也用`unlock()`释放对锁的控制\n```\npublic void printJob(Object doc){\n        queueLock.lock();\n        try {\n            long duration = (long) (Math.random()*10000);\n            System.out.println(Thread.currentThread().getName()+\" OrintQueue Printing a job during \"+(duration/1000)+\"second\");\n            Thread.sleep(duration);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            queueLock.unlock();\n        }\n    }\n```\n\n#### 使用读写锁实现同步数据的访问\n+ `ReadWriteLock`接口和他的实现类`ReenteantReadWriteLock`。这两个类有两个锁，一个是读操作锁(可同时允许多个人访问)，一个是写操作锁(同一时段只能一个线程操作)\n```\npublic double getPrice2(){\n        lock.readLock().lock();\n        double value = price2;\n        lock.readLock().unlock();\n        return value;\n    }\n\n    public void setPrice1(double price1,double price2){\n        lock.writeLock().lock();\n        this.price2=price2;\n        this.price1=price1;\n        lock.writeLock().unlock();\n    }\n```\n","tags":["Java","多线程"]},{"title":"线程同步基础之synchronized同步","url":"/archives/65a2a3a3.html","content":"## 线程同步基础之synchronized同步\n#### Java API提供的两种基本的同步机制\n1. synchronized关键字机制\n2. Lock接口及其实现机制\n\n#### synchronized关键字概述\n1. 对方法的声明定义\n\t+ 对于非静态方法，每个用synchronized关键字声明的方法都是一个临界区，对于同一个对象的临界区，再同一时间只有一个允许被访问\n\t+ 对于静态方法，\n2. synchronized同步块\n3. synchronized修饰一个类\n\n#### 使用synchronized实现同步非静态方法\n+ 使用synchronized修饰一个非静态方法是时候，修饰的是本方法，同一时间只能允许一个访问权限\n```\n    public synchronized void addAccount(double amount){\n        double tmp = balance;\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        tmp += amount;\n        balance = tmp;\n    }\n```\n\n#### 使用synchronized实现同步静态方法\n+ 我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象\n```\npublic synchronized static void method() {\n   // todo\n}\n```\n\n#### synchronized修饰代码块\n+ 当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块\n+ 当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块\n+ 当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞\n```\npublic void method()  \n{\n    synchronized(表达式)  \n     {  \n     }   \n}\n```\n+ 如果同步快里面的表达式是`this`关键字或者是`CLassName.class`关键字的话，作用的对象是这个类的所有对象\n\n#### 使用非依赖属性实现同步\n+ 线程同步控制过程中，创建一个无关属性，被多个线程共享使用，在同步操作中，同步对这个非依赖属性的访问\n\n#### 在同步代码中使用条件\n+ `wait()`:当一个线程调用`wait()`方法的时候，JVM将这个线程置入休眠，并且释放这个同步代码块的对象\n+ `notify()`与`notifyAll()`：唤醒之前因为调用`wait()`方法的线程\n+ 下面是生产者消费者模式里面的一个同步方法:当库存为零的时候，休眠次线程，不断的监听，库存是否继续为零\n```\npublic synchronized void get(){\n        while (storage.size()==0){\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"Get : \"+storage.size()+\" \"+((LinkedList<?>)storage).poll());\n            notifyAll();\n        }\n    }\n```\n","tags":["Java","多线程"]},{"title":"Java反射机制之动态代理","url":"/archives/faa9c2f.html","content":"## Java反射机制之动态代理\n\n#### 代理模式概述\n+ 定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象，如图：\n[代理模式(以静态代理为例)](http://aliosw.oss-cn-hangzhou.aliyuncs.com/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.gif)\n+ 上图中：\n\t+ RealSubject是原对象\n\t+ Subject是委托对象与代理对象都要实现的接口\n\t+ `request()` 是代理对象与委托对象都拥有的方法\n+ 代理模式分类：\n\t+ 静态代理：代理类是在编译时就实现好的.也就是说 Java 编译完成后代理类是一个实际的 class 文件\n\t+ 动态代理：代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中\n\n#### 动态代理概述\n+ Java反射机制你可以在运行期动态的创建接口的实现\n+ 动态的代理的用途十分广泛，比如数据库连接和事物管理（transaction management）还有单元测试时用到的动态 mock 对象以及 AOP 中的方法拦截功能等等都使用到了动态代理\n\n##### 实现步骤\n+ 定义一个委托类和公共接口\n+ 自己定义一个类(调用处理器,即是实现`InvacationHandler`接口)，指定运行时将生成的代理类需要完成的具体任务\n+ 动态生成代理对象，指定委托对象实现的一系列接口调用处理器的实例\n+ 通过代理对象调用方法\n\n##### Java API提供实现动态代理的类或接口\n1. Proxy(java.lang.reflect.Proxy):这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类(`DynamicProxyClass extends Proxy`)\n\t2. 创建代理对象的方法：`static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)`,其中，以一个参数是类加载器，第二个参数是需要代理类实现的接口，第三个参数是调用处理器类实例\n\t3. `InvocationHandler getInvocationHandler(Object proxy)`: 获得代理对象对应的调用处理器对象\n\t4. `Class getProxyClass(ClassLoader loader, Class[] interfaces)`: 根据类加载器和实现的接口获得代理类\n\n2. InvocationHandler(`java.lang.reflect.InvocationHandler`):动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口\n\n#### 动态代理Demo Codes Showed\n```\npackage xyz.royleo.Proxy;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\n/**\n * Created by RoyLeo on 2016/10/14.\n */\npublic class DynamicProxyDemo {\n    public static void main(String[] args) {\n        RealSub realSub = new RealSub();\n        ProxySub handler = new ProxySub(realSub);\n        Sub proxySubject = (Sub) java.lang.reflect.Proxy.newProxyInstance(RealSub.class.getClassLoader(),RealSub.class.getInterfaces(),handler);\n        proxySubject.request();\n    }\n}\n\ninterface Sub{\n    void request();\n}\n\nclass RealSub implements Sub{\n    @Override\n    public void request() {\n        System.out.println(\"RealSub-----Request\");\n    }\n}\n\nclass ProxySub implements InvocationHandler{\n    private Sub sub;\n    public ProxySub(Sub sub) {\n        this.sub = sub;\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"=====Before======\");\n        Object result = method.invoke(sub, args);\n        System.out.println(\"=====After=======\");\n        return result;\n    }\n}\n```\n","tags":["Java","动态代理"]},{"title":"Java反射机制之方法操作","url":"/archives/affd1e49.html","content":"## Java反射机制之方法操作\n\n#### 获取方法对象\n+ `Method[] methods = aClass.getMethods();`返回的 Method 对象数组包含了指定类中声明为公有的(public)的所有变量集合\n+ `Method method = aClass.getMethod(\"doSomething\", new Class[]{String.class});`返回方法名为doSomeThing，参数为String的方法对象\n+ `Method method = aClass.getMethod(\"doSomething\", null);`返回无参方法\n+ `Method privateStringMethod = PrivateObject.class.\n        getDeclaredMethod(\"getPrivateString\", null);`返回私有\n\n#### 方法参数以及返回类型\n+ `Class[] parameterTypes = method.getParameterTypes();`获取指定方法的方法参数\n+ `Class returnType = method.getReturnType();`获取指定方法的返回类型\n\n#### 通过Method对象调用方法\n```\nClass myClass = Result.class;\n        Result result = new Result();\n        Method method = myClass.getMethod(\"getName\");\n        Method method1set = myClass.getMethod(\"setName\",String.class);\n        method1set.invoke(result,\"TENYUAN\");\n        System.out.println(method.invoke(result));\n```\n","tags":["Java","动态代理"]},{"title":"Java反射机制之变量操作","url":"/archives/b0d70fcf.html","content":"## Java反射机制之变量操作\n\n#### 获取Field对象\n+ `Field[] methods = aClass.getFields();`返回Field 对象数组包含了指定类中声明为公有的(public)的所有变量集合\n+ `Field field = aClass.getField(\"someField\");`获得指定变量,如果没匹配到对应的变量，抛异常`NoSuchFieldException`\n+ `Field[] fields = myClass.getDeclaredFields();`获取私有成员变量\n\n#### 获取变量名称\n+ `String fieldName = field.getName();`\n\n#### 获取变量类型\n+ `Object fieldType = field.getType();`\n\n#### 获取或设置{get/set}变量值\n+ 一旦获得了一个 Field 的引用，你就可以通过调用 Field.get()或 Field.set()方法，获取或者设置变量的值\n+ 获取\\设置普通成员变量的值\n```\n Class myClass = Result.class;\n        Result result = new Result();\n        Field f = myClass.getField(\"omg\");\n        f.set(result,\"appAPP\");\n        System.out.println(f.get(result));\n```\n+ 获取\\设置私有变量的值：需要设置私有变量的访问权限`field.setAccessible(true)`\n```\n Class myClass = Result.class;\n        Result result = new Result();\n        Field f = myClass.getDeclaredField(\"name\");\n        f.setAccessible(true);\n        f.set(result,\"appAPP\");\n        System.out.println(f.get(result));\n```\n","tags":["Java","动态代理"]},{"title":"Java反射机制之构造器操作","url":"/archives/41e0f7bf.html","content":"## 构造器反射\n\n#### 获取Constructor对象\n1. `Constructor[] constructors = aClass.getConstructors();`获取构造器数组\n2.  `Constructor constructor =\n  aClass.getConstructor(new Class[]{String.class});` 根据具体的构造器参数获取指定的构造器，如果没有匹配的方法，则抛异常`NoSuchMethodException`\n\n#### 构造器参数\n1. `Class[] parameterTypes = constructor.getParameterTypes();`获取构造器的方法参数信息\n\n#### 利用构造器对象实例化一个类\n+ constructor.newInstance()方法的方法参数是一个可变参数列表，但是当你调用构造方法的时候你必须提供精确的参数，即形参与实参必须一一对应\n```\nConstructor constructor = Result.class.getConstructor(new Class[]{String.class});\n        Result result = (Result) constructor.newInstance(\"tettt\");\n        System.out.println(result.getName());\n```\n","tags":["Java","动态代理"]},{"title":"Java线程管理","url":"/archives/b7f7cee0.html","content":"## 线程管理\n\n#### 线程的创建与运行\n1. 线程创建：\n\t2. 继承Thread类，并且覆盖run()方法\n\t3. 创建一个实现`Runnable`接口的类，并且覆盖`run()`方法，使用带参数的`Thread`构造器来创建`Thread`对象，这个参数就是实现`Runnable`接口的类的一个对象\n4. 线程的运行：\n\t5. 线程对象调用`start()`方法，才会创建运行这个线程(线程创建，运行的时间点).\n\n#### 线程信息的获取和设置\n1. 线程的状态(status):`Thread.getStatus()`\n2. 线程的唯一标识符(Id):`Thread.getId()`\n3. 线程的名称(Name):`Thread.getName()`\n4. 线程的优先级(Property):`Thread.getPrioity()`\n\n#### 线程的中断\n1. 线程中断方法：`Thread.interrupt()`调用时，Thread类里面标记线程是否中断的属性(interrupted)被标记为true\n2. 检查线程是否中断：返回interrupted的属性值\n\t3. `Thread.interrupted()`\n\t4. `Thread.isInterrupted()`(能设置interrupt的属性为false)\n\n#### 线程的休眠与恢复\n+  `sleep(long timeouts)`:线程休眠指定时间，休眠期间，线程会释放CPU并且不在继续执行任务\n\n#### 等待线程的终止\n+ `Thread1.join()`:等待Thread1线程执行完之后才运行其他线程或者任务(适用于一些初始化任务等...)\n\n#### 守护线程的创建与运行\n1. 守护线程：优先级很低，当程序中没有其他的线程运行的时候，才运行守护线程，然后JVM就结束程序\n2. 创建：`setDaemon(true)`创建守护线程(守护线程必须先在`start()`方法被调用之前设置)\n\n#### 线程中不可控异常处理\n1. 非运行时异常(Checked Exception)：这种异常必须在方法声明用throws语句来指定，或者在方法内捕获(例如：IOException,ClassNotFoundException..)\n2. 运行时异常(Unchecked Exception)：不必在方法声明指定，也不必捕获(例如：NumberFormatException)\n3. `run()`方法不支持throws语句\n\n#### 线程局部变量\n+ 避免一个线程中改变了一个属性，所有线程都会被这个改变而影响\n+ 用法：通过声明一个`ThreadLocal<T>`对象，这个对象是在`initialValue()`方法中隐式实现的.\n```\n private static ThreadLocal<Date> startDate = new ThreadLocal<Date>(){\n        @Override\n        protected Date initialValue() {\n            return new Date();\n        }\n    };\n```\n\n#### 线程的分组\n+ 把一个组的线程当作一个单一的单元，对组内线程对象进行访问并操作它们\n+ 创建：通过创建线程数组，创建线程组，`ThreadGroup.enumerate(Thread[] threads)`获取线程组包含的线程列表\n\n#### 通过工厂类创建线程\n+ 创建：实现`ThreadFactory`接口，`@override newThread(Runnable r)`创建线程对象\n","tags":["Java","多线程"]},{"title":"'Mysql多表操作以及其实例'","url":"/archives/971c3dff.html","content":"## Mysql多表操作及其实例\n\n#### 数据表：\n+ 学生表\n```\n+---------+-------------+------+-----+---------+----------------+\n| Field   | Type        | Null | Key | Default | Extra          |\n+---------+-------------+------+-----+---------+----------------+\n| stuId   | int(11)     | NO   | PRI | NULL    | auto_increment |\n| classId | int(11)     | YES  |     | NULL    |                |\n| stuName | varchar(10) | YES  |     | NULL    |                |\n+---------+-------------+------+-----+---------+----------------+\n3 rows in set (0.01 sec)\n```\n+ 成绩表\n```\nmysql> desc score;\n+---------+-------------+------+-----+---------+-------+\n| Field   | Type        | Null | Key | Default | Extra |\n+---------+-------------+------+-----+---------+-------+\n| classId | int(11)     | YES  |     | NULL    |       |\n| stuId   | int(11)     | YES  |     | NULL    |       |\n| course  | varchar(10) | YES  |     | NULL    |       |\n| score   | int(11)     | YES  |     | NULL    |       |\n+---------+-------------+------+-----+---------+-------+\n4 rows in set (0.00 sec)\n```\n+ 班级表\n```\nmysql> desc class;\n+-----------+-------------+------+-----+---------+----------------+\n| Field     | Type        | Null | Key | Default | Extra          |\n+-----------+-------------+------+-----+---------+----------------+\n| classId   | int(11)     | NO   | PRI | NULL    | auto_increment |\n| className | varchar(20) | YES  |     | NULL    |                |\n+-----------+-------------+------+-----+---------+----------------+\n2 rows in set (0.00 sec)\n```\n\n####  数据库操作用例\n1. 查询“语文”课程比“数学”课程成绩高的所有学生的学号\n```\nselect * from (select stuId,score from score where course='语文' ) a,\n(select stuId,score from score where course='数学') b,(select * from student) c\n where a.stuId=b.stuId and a.score>b.score and a.stuId=c.stuId;\n```\n2. 查询平均成绩大于60分的同学的学号和平均成绩\n```\nselect stuId,avg(score) from score group by stuId having avg(score)>60;\n```\n3. 查询所有同学的学号、姓名、选课数和平均成绩\n```\nselect student.stuId,student.stuName as '姓名',count(score.classId),sum(score.score) as '所选课程总分'\nfrom student left join score on student.stuId=score.stuId group by student.stuId\n```\n4. 查询所有姓'雷'的学生个数\n```\nselect count(student.stuName) from student where stuName like '雷%'\n```\n5. 查询所有课程成绩小于60分的同学的学号，姓名\n```\nselect student.stuId,student.stuName from student where stuId not in\n (select score.stuId from score where score.score>85)\n```\n6. 查询各科的最高分的学生的学号，姓名等信息\n```\nSELECT *,max(score) as max FROM info.score,info.student\nwhere student.stuId=score.stuId group by score.course;\n```\n7. 查询各班的第一名学生的信息，按照班级排序\n```\nSELECT *,max(score) as max FROM info.score,info.student ,info.class\nwhere student.stuId=score.stuId and student.classId=class.classId group by class.classId order by class.className;\n```\n","tags":["Mysql"]},{"title":"epuals与'=='区别","url":"/archives/d2cfd72b.html","content":"\n### Java数据类型分类\n+ 基本数据类型(原始类型)：byte short char int long float double boolean\n\t+ 他们的比较，使用`==`,比较的是他们的值\n+ 复合数据类型(类定义)\n\t+ 他们通过`==`比较的时候，比较的是他们存放的内存地址，所以，除非是同一个new出来的对象，他们的比较结果是true，否则，比较结果是false\n\t+ Java所有的对象都是继承自IObject这个基类，在Object基类中定义了一个`equals()`的方法,这个对象的初始行为是比较对象的内存地址，但是有一些类库中，将这个方法覆盖掉了，如String，Integer，Date在这些类中equals()有着自身的实现，不再是比较类在堆内存中的存放地址。\n\t+ 而对于，那些木有覆盖`equals();`方法的的复合数据类型，他们之间的比较还是比较存放在内存中的地址值，与使用`==`比较结果相同\n\n\n### `==`操作\n+ “==”或等号操作在Java编程语言中是一个二元操作符，用于比较原生类型和对象。\n+ 就原生类型如boolean、int、float来说，使用“==”来比较两者，这个很好掌握。但是在比较对象的时候，就会与equals()造成困惑。“==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false。\n\n\n### `equals();`方法\n+ equals()方法定义在Object类里面，根据具体的业务逻辑来定义该方法，用于检查两个对象的相等性。\n+ 例如：两个Employees被认为是相等的如果他们有相同的empId的话，你可以在你自己的domain对象中重写equals方法用于比较哪两个对象相等。\n+ equals与hashcode是有契约的（无论什么时候你重写了equals方法，你同样要重写hashcode()方法），默认的equals方法实现是与“==”操作一样的，基于业务需求重写equals方法是最好的实践之一，同样equals与compareTo保持一致也不足为奇，以至于存储对象在Treemap或treeset集合中时，将使用compareTo方法检查相等性，行为是一致的。\n\n### `==`与`equals();`区别\n+ ==常用于比较原生类型，而equals()方法用于检查对象的相等性。\n+ 另一个不同的点是：如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。\n\n### 献上代码：\n```\n/**\n * Created by RoyLeo on 2016/9/12.\n */\npublic class main {\n    public static void main(String[] args){\n        String t1 = \"你好啊\";\n        String t2 = \"你好啊\";\n        String tt = t2;\n        String t3 = new String(\"你好啊\");\n        String t4 = new String(\"你好啊\");\n        String ttt = t3;\n        System.out.println(ttt==t4);             //false\n        System.out.println(ttt==t3);            //true\n        System.out.println(t1==t2);             //true\n        System.out.println(t1==t3);             //false\n        System.out.println(t3==t4);             //false\n        System.out.println(t1.equals(t2));      //true\n        System.out.println(t1.equals(t3));      //true\n        System.out.println(t3.equals(t4));      //true\n    }\n}\n\n```\n","tags":["Java"]},{"title":"v2ray_科学手段","url":"/archives/4be26d16.html","content":"#### For Windows\n+ 下载\n    1. [Win32](http://aliosw.oss-cn-hangzhou.aliyuncs.com/v2rayn_v2.14_win32.zip)\n    2. [Win64](http://aliosw.oss-cn-hangzhou.aliyuncs.com/v2rayn_v2.14_win64.zip)\n+ 安装\n    1. 安装 解压后，双击文件夹内的 V2RayN.exe 即可运行，如闪退请确认电脑系统是否缺少.NET 4.5（最低 4.5）\n    2. ![安装/运行](http://aliosw.oss-cn-hangzhou.aliyuncs.com/v2ray_forwin.gif)\n+ 配置\n    1. 账户导入：导入账号的方法有很多种，比如从剪切板导入批量 URL、扫描屏幕二维码、手动填写账号信息和导入配置文件等，前两个方法在 PC 端最为常用。\n    2. 例如：![剪切板导入](http://aliosw.oss-cn-hangzhou.aliyuncs.com/v2ray_win_config.gif)\n    3. 如上图所示，先复制 V2Ray 账号 URL，在右键点击屏幕右下角 V2RayN 图标，选择从剪切板导入批量 URL，点击弹出的确认按钮即可；扫描屏幕二维码的导入方式也很好理解，在电脑屏幕上打开 V2Ray 账号的二维码图片，右键点击屏幕右下角 V2RayN 图标，选择扫描屏幕二维码。\n    4. V2rayn算是局部代理，可以选择配合chrome插件试用，比如： SwitchyOmega等，SwitchyOmega配置可先自行搜索，如果必要，后面再补上\n    5. 必要配置：\n![配置](http://aliosw.oss-cn-hangzhou.aliyuncs.com/v2ray_for_mac_%E5%BF%85%E8%A6%81%E8%AE%BE%E7%BD%AE.gif)\n#### For Android(BifrostV)\n+ 下载链接\n    + [BifrostV](http://aliosw.oss-cn-hangzhou.aliyuncs.com/Bifrostv_v0.5.16_newfgq.com.apk)\n+ 配置\n    1. 可选择手动配置，导入配置，扫描二维码形式配置等，如使用过ss/ssr客户端的用户，操作步骤基本一样，可操作性强\n    2. 上图：\n    ![BifrostV 页面](http://aliosw.oss-cn-hangzhou.aliyuncs.com/bifv_page_1.png)\n    ![添加账号](http://aliosw.oss-cn-hangzhou.aliyuncs.com/brfg_p_2.png)\n    ![账号设置](http://aliosw.oss-cn-hangzhou.aliyuncs.com/bifg_p3.png)\n\n#### 声明\n+ 此文仅用于学习研究试用，仅做笔记整理，如有其他用途，与本站无关\n\n \n","tags":["V2ray"]},{"title":"原生JDBC操作数据库的思考总结","url":"/archives/861d9c25.html","content":"\n#### 前言\n+ 相信很多java工程师在入门Java操作数据库的时候，都是首先接触到JDBC连接数据库的方式访问操作数据库，对数据库进行增删查改(CRUD)\n+ 但是久而久之，基于各种原因(团队\\需求)，后来就使用封装了JDBC的框架来访问数据库，比如`hibernate`,`Mybatis\\iBats`,我这里总结一下一些关于使用原生JDBC操作数据库的一些思考\n\n#### JDBC编程步骤\n1. 加载数据库驱动\n2. 创建并获取数据库链接\n3. 创建jdbc statement对象\n4. 设置sql语句\n5. 社会sql语句中的参数(使用preparedStatement预加载)\n6. 通过statement执行sql并获得结果\n7. 对sql执行结果进行解析\n8. 释放资源关闭数据库\n\n#### 问题总结\n1. 数据库链接，使用时就创建，不使用的时候就释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能\n假想方案：使用数据库连接池管理数据库连接\n2. 将sql语句英编码到Java代码中，如果要修改sql语句，需要重新编译Java代码，不利于系统维护\n假想方案：将sql语句配置在xml配置文件中，需要修改sql语句的时候直接在xml配置文件，不需要重新编译Java代码\n3. 向preparedStatement中设置参数，对占位符位置和设置参数值，硬编码到Java代码中，不利于系统维护\n假想方案：将sql语句以及占位符和参数全在配置文件中定义配置\n4. 从resultSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护\n假想方案：将查询的结果集，自动映射成Java对象\n5. 对于繁杂程度来说，要使用一堆编码，才能实现一丢丢的查询......\n","tags":["Java","Mysql"]},{"title":"java 重定向与转发的异同","url":"/archives/bef463.html","content":"### 重定向与请求转发的异同\n\n##### 同：\n+ 两种方式都能跳转到目标页面\n\n##### 异：\n+ 本质区别：\n  1. 请求转发是服务器行为，而重定向是客户端行为：\n    + 转发过程：browser http请求----> web server接受请求----> 调用内部的一个方法在容器内部完成请求处理和转发 动作----->将目标资源发生给客户端；转发路径必须经过web容器的url，不能转向到其他的web路径，中间传递的是自的容器内的request. 而在客户端浏览器地址栏显示出来的是第一次访问的路径。也就是说，转发行为是浏览器只做了一次访问请求\n    + 重定向过程：browser http请求----> web server接受后发送302状态码以及对应新的location地址给客户端----> 客户端发现302状态码，则自动再转发一个新的http请求，请求url是新的location地址 ---->服务器根据此请求寻找资源并发送给客户. 重定向行为是浏览器做了至少两次访问请求.\n  2. 对于请求次数的解析：\n    + 重定向在客户端 request A ,server响应状态码，指示browser应该访问 B. 这时候可以看到地址栏发生变化。重定向可以访问自己web应用以外的资源，在充定向过程中，传输的信息会丢失\n    + 请求转发是在服务器内部一个request/response的处理权移交，对于客户端来说，它只知道自己最早的请求的那个A但是不知道中间其他的访问路径，传输信息不会丢失\n\n+ 从数据分享角度：\n  + 请求转发的转发页面与转发目标页面可以共享request里面的数据\n  + 重定向的跳转页面之间不可以共享数据\n\n+ 从运用角度：\n  + 请求转发一般用于用户登录的时候，或者角色转发到响应的模块\n  + 重定向一般用于用户注销登陆时返回和跳转到其他网站等\n\n+ 从效率角度：\n  + 请求转发效率比重定向效率高\n\n+ 内部实现：\n  + 请求转发部分：servlet主要负责处理具体的请求转发。通过获得RequestDispatcher对象，然后用forward方法进行请求转发\n  ```\n  RequestDisapatcher rd=reqest.getRequestDisapatcher();\n  rd.forward(req,resp); //用这里的方法来进行转发\n   ```\n  + sendRedirect方法属于HttpServletResponse对象的getRequestDispatcher方法得到\n","tags":["Java","Web"]},{"title":"TCP通信三次握手协议原理与过程分析","url":"/archives/5574abb0.html","content":"\n### TCP传输标志位解析：\n1. SYN(synchronous建立联机) ：请求建立连接的数据包\n2. ACK(acknowledgement 确认) ：回应数据包，表示接收到了对方的某个数据包\n3. PSH(push传送) ：正常数据包\n4. FIN(finish结束) ：通讯结束包\n5. RST(reset重置) ：重置连接\n6. URG(urgent紧急) ：紧急指针\n7. Sequence number(顺序号码) \n8. Acknowledge number(确认号码)\n\n### TCP通信建立连接(三次握手)原理\n1. 客户端通过向服务器端发送一个SYN来建立一个主动打开，作为三路握手的一部分\n2. 服务器端应当为一个合法的SYN回送一个SYN/ACK\n3. 最后，客户端再发送一个ACK，这样三次握手就完成，并进入到建立连接部分\n\n<center>\n![TCPBuild](http://aliosw.oss-cn-hangzhou.aliyuncs.com/tcpbiuld.png)\n</center>\n\n### 建立连接过程分析\n+ 过程\n1. 第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；\n2. 第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包\n3. 第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。\n+ 实例：\n```\nIP 192.168.1.116.3337 > 192.168.1.123.7788: S 3626544836:3626544836\n IP 192.168.1.123.7788 > 192.168.1.116.3337: S 1739326486:1739326486 ack 3626544837\n IP 192.168.1.116.3337 > 192.168.1.123.7788: ack 1739326487,ack 1\n```\n+ 分析：\n1. 第一次握手：从192.168.1.116的端口3337发送位码syn=1,随机产生seq number=3626544836的数据包到192.168.1.123端口7788由syn=1知道192.168.1.116要求建立联机\n2. 第二次握手：192.168.1.123:7788收到请求之后要确认信息，向192.168.1.116:3337发送ack number=3626544837，syn=1，ack=1随机产生seq=1739326486的数据包\n3. 192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功\n\n### TCP连接建立过程为神马需要三次握手？\n+ 概述：传输控制协议（Transmission Control Protocol, TCP）是一种面向连接的、可靠的、基于字节流的运输层（Transport layer）通信协议，是专门为了在不可靠的互联网络上提供一个可靠的端到端字节流而设计的\n+ 目的：防止已经失效的连接请求突然又传送到服务端，因而产生错误(为了解决网络中存在延迟的重复分组)\n+ 例子说明：\n1. client发出的第一个连接请求报文段并没有消失，而是在网络某个节点上长时间滞留了，以致延误到连接释放以后的某个时间才到达server端. 而这个已经失效已久的连接到达server之后，就误认为是client新建立起来的连接，于是server向client发送数据，但是server却以为新的传输连接已经建立，于是就像client发出确认报文段，同意建立连接。\n2. 如果没有三次握手的过程，那么只要server发出确认，新的连接就建立，由于现在client并没有发出建立 连接的请求，因此不会理财server的确认，也不会向server发送数据，但server却以为新的传输连接已经建立，并一直等待client发来数据，这样的话，就会造成资源浪费\n3. 而采用三次握手过程，就可以避免上述现象，client不会向server的确认发出确认，server由于收不到确认，就知道client并没有建立连接\n\n\n\n","tags":["NetWorker"]},{"title":"Spring中添加REST功能","url":"/archives/4a1b8e6e.html","content":"#### REST基本原理：\n+ 通过简单的HTTP URL触发事件\n+ REST是将资源最合适地从服务端转移到客户端(或者反之)\n+ REST与RPC(远程过程调用)：REST面向资源，强调描述应用程序的事物和名词;RPC面向服务，关注于行为和行动\n#### Spring如何支持REST？\n+ 控制器可以处理所有的HTTP方法：GET、POST、DELETE、PUT...\n+ @PathVariable 注解使控制器能够处理参数化的URL(带参数变量的URL)\n+ Spring表单绑定JSP标签库的`<form:form>`标签以及新的HidenHttpMethodFilter，使得通过HTML转发提交的PUT，DELETE请求成为可能(即使mou'xie)\n+ 使用String的视图和视图解析器，资源可以以各种形式表述，包括将数据模型表示为：XML、JSON、ATOM、RSS等\n+ 使用新的ContentNegotiatingResolver来选择合适的客户端表述\n+ 类似的，使用@ResponseBody注解以及HttpMethodConverter实现可以将传入的HTTP数据转化为传入控制器的处理方法的Java对象\n+ RestTemplate简化客户端对REST资源的使用\n\n#### RESTful URL\n+ 格式：`http://localhost:8080/spitter/spittles/123`\n\t+ 协议：//域名：端口号/Servlet上下文路径/资源类型/特定的spittle\n\t+ REST　URL是用来标识资源\n+ RESTful　URL是有层级结构的，每个层标识一种资源\n+ 其中，URL还可以参数化，在控制器中获取该参数`@PathVariable(\"id\") long id`\n\n#### 执行REST动作\n+ HTTP提供来操作资源的方法，主要是四个\n\n|方法|描述|是否安全|\n|---|---|---|\n|GET|从服务器上检索资源信息，资源通过请求的URL来进行标识|是|\n|POST|传送数据到服务器，数据会由监听该请求的URL处理器进行处理|否|\n|PUT|按照请求的URＬ，防治资源到服务器指定位置|否|\n|DELETE|将请求URL标识的资源从服务器上删除|否|\n\n#### 表述资源\n+ Spring提供两种形式，将资源的Java表述形式转换为发送给客户端的表述形式：\n\t+ 基于视图渲染进行协商\n\t+ HTTP消息转换器\n+ 协商资源表述\nbean配置:\n``` <!-- 根据客户端的不同的请求决定不同的view进行响应, 如/blog/1.json/blog/1.xml-->\n    <bean class=\"org.springframework.web.servlet.view.ContentNegotiatingViewResolver\">\n<!-- 设置为true以忽略对Accept Header的支持-->\n         ##<property name=\"ignoreAcceptHeader\" value=\"true\"/>\n <!-- 在没有扩展名时即: \"/user/1\" 时的默认展现形式 -->\n        <property name=\"defaultContentType\" value=\"text/html\"/>\n<!-- 扩展名至mimeType的映射,即 /user.json => application/json -->\n        <property name=\"mediaTypes\">\n            <map>\n                <entry key=\"json\" value=\"application/json\" />\n                <entry key=\"xml\" value=\"application/xml\" />\n            </map>\n        </property>\n    </bean>```\n1. 确定请求的媒体类型\n\t+ ViewResolver首先查找URL中的文件扩展名，将文件扩展名与mediatype的条目匹配，如果找到匹配项，则使用该媒体类型，并覆盖accpt头信息中的任何媒体类型\n\t+ 如果找不到URL中的扩展名，那么就使用Accept中的头信息的媒体类型\n\t+ 如果请求头中不包含Accept头信息，那么就使用defaultContentType属性中设置的媒体类型\n2. 影响如何选择类型\n\t+ 将favorPathExtension属性设置为false，将会使得ContextNegotiatingViewResolver忽略URL路径扩展名\n\t+ 将JAF添加到类路径下将会使得ContextNegotiatingViewResolver除了使用mediaTypes属性中的条目外，在路径扩展名确定媒体类型时还会借助JAF\n\t+ 将favorParameter属性设置为true，并且请求中包含名为format参数，那么format参数的值将会mediatype属性来进行匹配，即使URL文件中没有文件扩展名也能匹配其中的媒体类型\n\t+ ignoreAcceptHeader属性设置为true，将会忽略Accept头信息\n3. 查找视图\n\t+\tContextNegotiatingViewResolver循环所有保存的媒体类型，找到能与之匹配内容类型的视图，完成视图解析匹配\n\t+\t如果ContextNegotiatingViewResolver没有找到合适的视图，那么它将返回null视图，或者如果useNotAcceptableStatusCode属性被设置为true，那么将返回带有http状态码406(Not Acceptable)的视图","tags":["Spring"]},{"title":"JSP九大内置对象、四个作用域以及六大基本动作","url":"/archives/ac0ee78d.html","content":"## 内置对象\n1. request：javax.servlet.ServletRequest的子类型，此对象封装了由WEB浏览器或其它客户端生成地HTTP请求的细节（参数，属性，头标和数据）\n\t+ 常用方法：getParameter、getParameterNames 和getParameterValues 通过调用这几个方法来获取请求对象中所包含的参数的值\n2. response： javax.servlet.ServletResponse的子类型，此对象封装了返回到HTTP客户端的输出，向页面作者提供设置响应头标和状态码的方式。经常用来设置HTTP标题，添加cookie，设置响应内容的类型和状态，发送HTTP重定向和编码URL\n3. out: javax.servlet.jsp.JspWriter类型，代表输出流的对象\n\t+ 常用的方法除了pirnt和println之外，还包括clear、clearBuffer、flush、getBufferSize和getRemaining，这是因为“out” 对象内部包含了一个缓冲区，所以需要一些对缓冲区进行操作的方法\n4. session: javax.servlet.http.HttpSession类型，主要用于跟踪对话;HttpSession是一个类似哈希表的与单一WEB浏览器会话相关的对象，它存在于HTTP请求之间，可以存储任\n何类型的命名对象;\n\t+ “session” 对象建立在cookie的基础上，所以使用时应注意判断一下客户端是否打开了cookie。常用的方法包括getId、 getValue、 getValueNames和putValue等\n5. pageContext: javax.servlet.jsp.PageContext（抽象类）类型;此对象提供所有四个作用域层次的属性查询和修改能力，它也提供了转发请求到其它资源和包含其他资源的方法 ,该对象的方法都是抽象方法，代表的是当前页面运行的一些属性\n\t+ 常用方法：findAttribute、getAttribute、getAttributesScope 和getAttributeNamesInScope\n\t+ 一般情况下pageContext对象用到得也不是很多，只有在项目所面临的情况比较复杂的情况下，才会利用到页面属性来辅助处理。\n6. application：javax.servlet.ServletContext类型，servlet的环境通过调用getServletConfig().getContext()方法获得;它提供了关于服务器版本，应用级初始化参数和应用内资源绝对路径，注册信息的方式得并设置会话属性\n\t+ 常用的方法有getMimeType和getRealPath等\n7. config：javax.servlet.ServletConfig类型，（页面执行期）\n\t+ 常用的方法有getInitParameter和getInitParameterNames，以获得Servlet初始化时的参数\n8. exception: java.lang.Throwable,通过JSP错误页面中一个catch块已经益出但没有捕获的java.lang.Throwable的任意实例，传向了errorPage的URI。作用域为page（页面执行期）。注意exception只有在page指令中具有属性isErrorPage=\"true\"时才有效。\n9. page:java.lang.Object类型，指向页面自身的方式\n\n## 内置对象与作用域对应关系\n|对象|对象名称|所属类|作用域|\n|---|---|---|---|\n|request|请求对象|javax.servlet.ServletRequest|Request|\n|response|相应对象|javax.servlet.SrvletResponse|Page|\n|pageContext|页面上下文|javax.servlet.jsp.PageContext|Page|\n|session|会话对象|javax.servlet.http.HttpSession|Session|\n|application|应用程序对象|javax.servlet.ServletContext|Application|\n|out|输出对象|javax.servlet.jsp.JspWriter|Page|\n|config|配置对象|javax.servlet.ServletConfig|Page|\n|page|页面对象|javax.lang.Object|Page|\n|exception|例外对象|javax.lang.Throwable|page|\n\n## 作用域\n|作用域|有效范围|\n|---|---|\n|pageContext|有效范围只是在当前jsp页面|\n|request|有效范围只是在当前请求周期|\n|session|当前会话(用户打开浏览器到用户关闭浏览器之间的过程),也就是说，只要用户不关浏览器，服务器就有办法知道这些请求是一个人发起的,整个过程被称为一个会话,而放到会话中的变量，就可以在当前会话的所有请求里使用|\n|application|整个应用(只要服务器不重启，都有效);与上述三个不同的是，application里的变量可以被所有用户共用|\n\n## 六种基本动作\n+ `<jsp:include page=\"\" />`: 在页面请求中包含一个文件\n+  `<jsp:useBean id=\"\" class=\"\" scope=\"application page request session\" />`:寻找或者实例化一个javaBean\n+ `<jsp:setProperty name=\"\" property=\"\" value=\"\" />`:设置javaBean的属性，通过反射调用方法\n+ `<jsp:getProperty name=\"\" property=\"\"/>`:取得某个javaBean的属性\n+ `<jsp:forward page=\"\"/>`:把请求转到一个新的页面\n+ `<jsp:plugin>`:插入Applet程序的代码\n+ `<jsp:param name=\"\" value=\"\" />`:用于传参数，和forward一起使用\n","tags":["Java","Servlet","Web"]},{"title":"Mybatis 实现原理与结构解析","url":"/archives/3fb7ed9.html","content":"\n### Mybatis概述\n+ Mybatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架\n+ 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索\n+ Mybatis使用简单的XML或注解用于配置和原始映射，将接口和Java的POJOs映射成数据库中的记录\n+ 每个Mybatis应用程序都是基于SqlSessionFactory实例，而一个SqlSessionFactory实例可以通过SqlSessionFactoryBuilder读取xml配置文件或者一个预定义的配置类的实例获得\n\n### Mybatis工作流程\n1. 加载配置并初始化\n+ 将SQL的配置信息加载成一个个`MappedStatement`对象(包括传入参数映射配置、执行SQL语句、结果映射配置)，存储在内存中\n2. 接受调用请求\n+ 触发条件：调用Mybatis提供的API\n+ 传入参数：为SQL的ID和传入参数对象\n+ 处理过程：将请求传递给下层的请求处理层进行处理\n3. 处理触发请求\n\t+ 触发条件：API接口层传递请求过来\n\t+ 传入参数：SQL的ID和传入参数的对象\n\t+ 处理过程：\n\t\t\t     1. 根据SQL的ID查找对应的MappedStatement对象\n\t\t\t     2. 根据传入的参数对象解析MappedStatement对象，最终得到要执行的SQL和执行传入参数\n\t\t\t     3. 获取数据库连接，根据得到的最终SQL语句和执行传入参数到数据库执行，并得到执行结果\n\t\t\t     4. 根据MappedStatement对象中的结果映射配置对得到的执行结果进行转换处理，并得到最终的处理结果\n\t\t\t     5. 释放连接资源\n4. 返回接受最终处理结果\n\n### 工作原理结构\n+ 功能架构：Mybatis的功能架构分为四层\n\t1. API接口层：提供给外部使用的API接口，开发人员通过这些本地的API来操纵数据库.接口层已收到调用请求就会调用数据处理层来完成具体的数据处理\n\t2. 数据处理层：负责具体的SQL查找，SQL解析，和结果执行映射处理等，其主要目的是根据调用的请求完成一次数据库的操作\n\t3. 基础支撑层：负责最基础的功能支撑，包括连接管理，事务管理，配置加载和缓存处理，这些都是共用的，将他们抽取出来作为最基础的封装组件，为上层的数据处理提供最基础的支撑\n\t4. 引导层：配置和启动Mybatis配置信息的方式，Mybatis提供两种方式来引导Mybatis：\n\t+ 基于XML配置文件获取配置信息\n\t+ 基于Java API的方式\n<center>\n![Mybatis功能架构](http://aliosw.oss-cn-hangzhou.aliyuncs.com/%E5%8A%9F%E8%83%BD%E6%9E%B6%E6%9E%84.png)\n</center>\n+ 框架架构：\n    1. 加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载为宜个MappedStatement对象(包括传入参数映射配置，执行的SQL语句，结果映射配置)　，存储在内存中\n    2. SQL解析：当API接口层接收到调用请求时，会接受到传入SQL的ID和传入对象(可以是Map、JavaBean对象或者是基本数据类型)，Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数\n    3. SQL执行：将最终得到的SQL语句和参数传入数据库中执行，得到数据库返回的执行结果\n    4. 结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap，JavaBean或者基本数据类型，并将最终结果返回\n<center>\n![Mybatis框架架构](http://aliosw.oss-cn-hangzhou.aliyuncs.com/%E5%8A%9F%E8%83%BD%E6%9E%B6%E6%9E%84.png)\nPanda\n</center>\n","tags":["Mybatis"]},{"title":"Java 迭代器Iterator的用法","url":"/archives/4b2bec15.html","content":"### 迭代器(Iterator)概述\n+ Iterator是作为一个接口存在的，它定义了迭代器所具有的功能\n+ 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构;迭代器通常被称为“轻量级”对象，因为创建它的代价小.\n\n### 迭代器的好处\n1. 迭代器可以提供统一的迭代方式。\n2. 迭代器也可以在对客户端透明的情况下，提供各种不同的迭代方式。\n3. 迭代器提供一种[快速失败机制](http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtyfour.html)，防止多线程下迭代的不安全操作。\n\n### 功能方法\n+ 示例:\n```\nIterator<String> iter = list.iterator();\n\t\twhile(iter.hasNext())\n\t\t{\n\t\t\titer.next();\n\t\t\t//System.out.println(iter.next());\n\t\t}\n```\n+ Java中的迭代器功能比较简单，并且只能单向移动;\n+ 方法:`iterator();`要求容器返回一个Iterator;第一次调用Iterator的next()方法时，它返回序列的第一个元素\n+ `next();`获得序列中的下一个元素\n+ `hasNext();`检查序列中是否还有元素\n+ `remove();`将迭代器新返回的元素删除\n\n### 知识扩充(遍历List集合的方法)\n+ foreache 遍历：\n```\nfor(String tmp:list){\n\t\t\tSystem.out.println(tmp);\n\t\t}\n```\n+ for 循环遍历：\n```\nfor(int i = 0; i < list.size(); i++){\n\t\t\tlist.get(i);\n\t\t\tSystem.out.println(list.get(i));\n\t\t}\n```\n+ Iterator遍历(例子上面已经给出)\n+ 其中，对于同一个List集合，统计每个遍历方式时间消耗如下：\n```\nList first visit method(foreache):\nRun Time:170(ms)\nList second visit method(for):\nRun Time:10(ms)\nList Third visit method(Iterator):\nRun Time:34(ms)\n```\n+ 显而易见；迭代器遍历在时间上的优势很大，代码简洁\n+ 同时，与for/foreach 相比，Iterator使用相同方式去遍历集合中元素，而不用考虑集合类的内部实现(只要它实现了 java.lang.Iterable 接口)\n","tags":["Java"]},{"title":"Mysql视图技术原理与应用","url":"/archives/69b20980.html","content":"### 视图概述\n+ 定义：视图是一个虚拟表，其内容由查询定义，视图表内存在行列数据，但是不在数据库中以存储的数据值集形式存在，行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成.\n+ 更新过程：当查询视图时，数据库从相应的引用表中引入数据到视图表\n+ 视图技术优点：\n\t+ 视图能简化用户操作：视图机制使用户可以将注意力集中在所关心的数据上，使数据库看起来结构简单，清晰，并简化用户的查询操作\n\t+ 视图使用户能以多种身份看待数据：灵活地实现多种不同类型的用户共享同一个数据库\n\t+ 视图对重构数据库提供了不同程度上的逻辑独立性：重构时(数据库逻辑改变)，新增关系表或者对原有关系增加新字段，不会影响应用程序所需的数据查询形式\n\t+ 适当的利用视图可以更清晰地表达查询\n\n### 使用案例:\n#### 语法：\n+ `ALGORITHM`:定义查询算法\n\t+ `MERGE`:将查询视图的语句与视图的定义语句合并处理\n\t+  `TEMPTABLE`:视图查询的结果保存到临时表，而后在该临时表基础上执行查询视图的语句\n\t+  `UNDEFINED` : 由Mysql选择使用的算法，一般首选MERGE，因为MERGE更有效率，而且TEMPTABLE不支持更新\n+  WITH[CASCADED|LOCAL] CHECK OPTION 解析\n\t+  LOCAL参数表示更新视图时只要满足该视图本身定义的条件即可\n\t+  CASCADED参数表示更新视图时需要满足所有相关视图和表的条件;没有指明时，该参数为默认值\n```\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW [db_name.]view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION]\n```\n#### 创建视图：\n+ 在单表上创建：`create view vName(id,sex,age) as select id,sex,age from student;`\n+ 在多表上创建：`CREATE VIEW VName(ID, NAME, SEX, AGE,DEPARTMENT,POS,EXPERENCE) AS SELECT a.ID, a.NAME, a.SEX, a.AGE,a.DEPARTMENT,b.POS,b.EXPERENCE FROM learning.t_employee a,learning.t_employee_detail b WHERE a.ID=b.ID;`\n+ 查看视图：`DESCRIBE vName;`或`SHOW TABLE STATUS;`或`SHOW CREATE VIEW VnAME;`\n+ 修改视图：\n\t+ ` create or replace` 指令：`CREATE OR REPLACE VIEW V_VIEW1(ID, NAME, SEX) AS SELECT ID, NAME, SEX  FROM learning.t_employee; `\n\t+ `ALERT`指令: `ALTER VIEW  V_VIEW1(ID, NAME) AS SELECT ID, NAME  FROM learning.t_employee;`\n+ 更新视图：主要通过(insert,update,delete)操作表中数据；由于视图上的数据来自于基本表，更新视图虚拟表上的数据都会转换到基本表更新.\n\t+ 更新视图时，只能更新权限范围内的数据，超出范围，不能更新\n\t+ 指令实例：`update vName set project=\"psychonologic\" where id = 2;`\n\t+ 不可更新的视图：由于虚拟表对应实体表中的数据，所以不是所有的视图表都能更新；如果视图含有下列结构中的任何一种，则不能更新：\n\t\t+ 聚合函数(SUM(),MIN(),MAX(),COUNT()...)\n\t\t+ DISTINCT\n\t\t+ GROUP BY\n\t\t+ HAVING\n\t\t+ UNION/UNION ALL\n\t\t+ 位于选择序列中的子查询\n\t\t+ Jion\n\t\t+ FROM字句中的不可更新视图\n\t\t+ WHERE子句的子查询，引用FROM字句的表\n\t\t+ 仅引用文字值\n\t\t+ ALGORITHM = TEMPTABLE\n\t+ 对于更新操作的提醒：视图虽然可以更新数据，但是有很多限制，一般情况下，最好将视图作为查询数据的虚拟表，而不要通过视图更新数据. 对于一些结构更加复杂的数据库表，最好在实体表中更新数据","tags":["Mysql"]},{"title":"mysql触发器学与用","url":"/archives/64423a64.html","content":"### 简述：\n+ Mysql在5.0.2版本以上开始支持触发器，触发器是有某些带有命令的的时间来出发某些操作，这些事件操作包括 insert delete update...\n+ 触发器可以用于记录对数据库的操作，它是一种与表操作有关的数据库对象，当触发器所在表上出现某个触发事件以及触发事件时，将调用该对象。即表的操作事件触发表上的触发器的执行\n\n### 创建触发器\n+ 语法：\n```\nCRATE TRIGGER TRIGGER_NAME \nTRIGGER_TIME\nTRIGGER_EVENT ON TRIGGER_TABLE\nFOR EACH ROW\nTRIGGER_STATEMEMTS\n```\n+ 解析：\n\t+ TRIGGER_NAME : 表示触发器名称，用户自定义\n\t+ TRIGGER_TIME :  标识触发时机，取值为：before 、 after \n\t+ TRIGGER_EVENT : 标识触发事件，取值为：INSERT , UPDATE ,DELETE\n\t+ TRIGGER_TABLE ：标识建立触发器的表名，也就是触发器的表对象\n\t+ TRIGGER_STATEMENT：触发器程序体，可以是一条语句，或如果是多条语句，用`begin [stmt_list] end;`包含，但是每条语句之间用分好分隔\n\t+ 根据触发时机与触发事件的组合，可以看出，最多可以建立6种触发器(注：一个表上不能简历相同的触发器)\n+ 对于`begin...end`，由于中间使用了分号(mysql中标记执行完语句的符号)而导致begin找不到与之匹配的end，因此引入了`DELIMITER`命令，作为定界分隔符；`end$ DELIMITER ;`\n\n### 一个完整的触发器示例\n```\nDELIMITER $\ncreate trigger tri_stuInsert after insert\non student for each row\nbegin\ndeclare c int;\nset c = (select stuCount from class where classID=new.classID);\nupdate class set stuCount = c + 1 where classID = new.classID;\nend $\nDELIMITER;\n```\n+ mysql用使用DECLARE 来定义局部变量，并且该遍历只能在BEGIN...END之间使用，并且只能放在期间复合语句的开头\n```\n格式：DECLARE var_name[,...] type [DEFAULT value]\n```\n+ new与old：\n\t+ INSERT型触发器 ：NEW表示将要(BEFORE)或已经(AFTER)插入的新数据\n\t+ UPDATE型触发器：OLD用来表示将要或者已经被修改的原数据，NEW表示将要或者已经被修改的新数据\n\t+ DELETE型触发器：OLD用来表示将要或已经被删除的数据\n\t+ 并且，OLD是只读的，而NEW可以在触发器中使用set赋值，避免二次触发触发器，造成循环调用\n\n### 查看触发器\n+ 语法：可以在后面指定数据库名来查看触发器\n```\nshow triggers [from scheme_name];\n```\n\n### 删除触发器\n+ 语法：\n```\ndrop trigger [if exists] trigger_name;\n```\n\n### 触发器执行顺序\n+ 我们建立的数据库一般都是 InnoDB 数据库，其上建立的表是事务性表，也就是事务安全的。这时，若SQL语句或触发器执行失败，MySQL 会回滚事务，有：\n1. 如果 BEFORE 触发器执行失败，SQL 无法正确执行\n2. SQL 执行失败时，AFTER 型触发器不会触发\n3. AFTER 类型的触发器执行失败，SQL 会回滚","tags":["Mysql"]},{"title":"Java 实现TCP/IP Socket通信","url":"/archives/39b075e7.html","content":"##### Java提供的网络功能有四大类\n+ InetAddress; 用于标识网络上的硬件资源，比如MAC地址等．．．\n+ URL：统一资源定位符 通过URL可以直接读取或写入网络上的数据\n+ Sockets：使用TCP协议实现网络通信的Socket的相关类\n+ Datagram：使用UDP协议，将数据保存在数据报中，通过网络进行通信\n##### InetAddress类：表示互联网协议(IP)地址\n+ 通过静态方法获取实例：(然后就可以根据jdk文档，使用相关方法)\n```\nInetAddress address = InetAddress.getLocalHost();//或者\nInetAddress address1 = InetAddress.getByName(\"10.2.18.87\");\n```\n##### Socket实现TCP通信(基于数据流套接字)\n+ 建立连接流程： 服务器处于监听状态，等待并接受客户端创建的socket向服务器发送请求，服务器接收请求之后，创建连接Socket进行通信\n+ 开始通信：通过相关的输入流(InputStream)、输出流(OutputStream)，发送接收数据\n+ 结束通信：关闭客户端和服务端的socket，释放资源\n+ 实现步骤：\n\t1. 创建ServerSocket和Socket\n\t2. 打开连接到Socket的输入/输出流\n\t3. 按照协议对Socket进行读写操作\n\t4. 通信完毕，关闭输出流，关闭Socket\n+  服务端实现步骤：\n\t1.\t创建ServerSocket对象，绑定监听端口\n\t2.\t通过accept()方法绑定客户端请求\n\t3.\t建立连接后，通过输入流读取客户端发送的请求信息\n\t4.\t通过输出流向客户端发送响应信息\n\t5.\t关闭相关资源\n+ 客户端实现步骤：\n\t1.\t创建Socket对象，指明需要连接的服务器的地址与端口号\n\t2.\t连接创建后，通过输出流向服务器发送请求信息\n\t3.\t关闭相关资源\n+  主要方法：getInputStream(), getOutPutStream();实现发送/接受数据 \n+  多线程实现服务器与多客户端之间通信\n\t+  基本步骤：\n\t\t1. 在服务器端创建ServerSock，循环调用accept()等待客户端连接\n\t\t2. 客户端创建一个Socket并请求和服务端连接\n\t\t3. 服务端就收客户端请求，创建socket与该客户简历专线连接\n\t\t4. 建立链接的两个Socket在一个单独的线程上对话\n\t\t5. 服务器机箱等待新的连接\n##### UDP Socket编程\n+ 使用的类：DatagramPacket类，DatagramSocket类；可以在jdk文档里面了解其中方法的用法\n+ 服务端实现步骤：\n\t1. 创建DatagramSocket，指定端口号\n\t2. 创建DatagramPacket，用于接收客户端数据\n\t3. 接受客户端发送的数据\n\t4. 读取数据\n+ 客户端实现步骤\n\t1. 定义发送信息\n\t2. 创建DatagramPacket，包含要发送的数据信息\n\t3. 创建DatagramSocket\n\t4. 发送数据\n+ 同样，也可以通过像tcp Socket通信那样完善，添加多线程监控客户端请求并相应;\n+ 备注：程序代码都在Github 仓库：[enter link description here](https://github.com/liangqian/socketDemo.git) \n","tags":["Java"]},{"title":"struts2基础笔记(1)","url":"/archives/5970580b.html","content":"### Sturts2访问Servlet API\n+ 访问Servlet API的三种方式\n\t+ ActionContext：\n```\n ActionContext actionContext=ActionContext.getContext();  \nMap<String,Object> map=actionContext.getSession();  \nmap.put(\"hello\",\"helloworld\");  \n```\n\t+ 实现***Aware接口：通过实现指定接口ServletContextAware，ServletRequestAware，ServletResponseAware，这种方式不推荐使用，与ServletAPI的耦合性大\n```\npublic class LoginAction extends ActionSupport implements ServletRequestAware{ \n\tHttpSession session=request.getSession();\n\t//something same as httpSetvlet\n}\n```\n\t+ ServletActionContext：ServletActionContext是面向action,特定于上下文的信息。继承于ActionContext\n```\nHttpServletRequest request=ServletActionContext.getRequest();  \n    HttpSession session=request.getSession();  \n    session.setAttribute(\"hello\", \"helloworld\");\n```\n### Action的搜索顺序\n1. 发生URL请求：`http://localhost:80/projectName/path1/path2/path3/test.action`\n1.  首先会检索namespace为`/path1/path2/path3/`的package里面的test；如果找到则访问\n\t+ 否则，转向默认表空间[namespace=\"\"]里面寻找该action，找到则访问\n\t\t+ 否则，转向默认表空间[namespace=\"\"]寻找默认的action，找到则访问改action\n\t\t\t+ 如果默认空间中没有设置默认的action，则返回404....[not found]\n1.  首先会检索namespace为`/path1/path2/`的package里面的test；如果找到则访问\n\t+ 否则，转向默认表空间[namespace=\"\"]里面寻找该action，找到则访问\n\t\t+ 否则，转向默认表空间[namespace=\"\"]寻找默认的action，找到则访问改action\n\t\t\t+ 如果默认空间中没有设置默认的action，则返回404....[not found]\n1.  首先会检索namespace为`/path1/`的package里面的test；如果找到则访问\n\t+ 否则，转向默认表空间[namespace=\"\"]里面寻找该action，找到则访问\n\t\t+ 否则，转向默认表空间[namespace=\"\"]寻找默认的action，找到则访问改action\n\t\t\t+ 如果默认空间中没有设置默认的action，则返回404....[not found]\n1.  如果仍然不存在这个package,就去默认的namaspace的package下面去找名字为test的action(默认的命名空间为空字符串\"\"),\n   如果还是找不到,页面提示找不到action,报404找不到内容的错误\n\n### 动态方法调用\n+ 概述：解决一个action对应多个请求的处理的问题，简化开发，避免Action太多\n+ 方法一：指定Method属性\n\t+ 在配置文件中指定访问方法(method)：\n``` <action name=\"hello\" class=\"hellow\" method=\"execute\">\n<result name=\"success\">/result.jsp</result>\n</action>\n ```\n \n+ 方法二：感叹号方式\n\t+ 开启常量值配置：`<constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"></constant>`\n\t+ 根据返回值在`<result>`里面用name指定视图：`<result name=\"result\">/result.jsp</result>`\n\t+ 调用在action后缀之前添加感叹号和方法的方式访问：`http://localhost:8080/testStruts2/hello!result.action`\n+ 方法三：通配符方式\n\t+ 在`<action>`配置里面name属性后面用`_*`的方式统配参数：第一个星号对应参数{1},第二个星号对应第二个参数{2}，可以统配包名，类名，方法名，或者部分名称的切割\n\n```\n <action name=\"hello_*_*\" class=\"{1}\" method=\"execute\">\n<result name=\"success\">/{2}.jsp</result>\n  </action>\n  ```\n### 指定多个配置文件\n+ 项目中action特别多，如果全在一个`struts.xml`里面，就很复杂\n+ 可以通过<include>导入多个分割了的action配置文件模块：`<include file=\"hello.xml\"></include>`\n+ 也可以统一配置文件的编码：用`<constrant>`\n### 默认action\n+ 防止出现尴尬页面.....\n+ 在`struts.xml`配置文件配置:\n```\n<default-action-ref name=\"hello\"></default-action-ref>\n<action name=\"hello\"><result name=\"error\">/error.jsp</result></action>\n```\n### struts2后缀：\n+ 伪造页面，安全，防hacker\n+ 改成html后缀：`<constant name=\"struts.action.extension\" value=\"html\"/>`\n+ 取消后缀,只需消息value的值：`<constant name=\"struts.action.extension\" value=\"\"/>`\n+ 也可以在struts.properties里面配置，还可以在里面配置多个参数\n+ 可以在web.xml里面配置<init-param>来指定后缀\n### 接收参数：\n+ 方法一：使用Action属性接收：\n\t+ 在接受的类中创建与提交部分命名一致的属性，以及getter，setter；传过来 的时候就能接收\n+ 方法二：使用Domain Model接收：\n\t+ 创建对象model来接收，为了将数据存入到指定的对象模型，在提交数据的时候，需要指定存入的已经实例化的对象的属性\n```\n <label>用户名：</label><input type=\"text\" name=\"us.username\">\n  <label>密  码：</label><input type=\"password\" name=\"us.password\">\n```\n+ 方法三：使用ModelDriven接收：\n\t+ 实现ModelDriven的接口；如果通过对象接受数据，必须实例化，并且，在提交数据的时候，不需要再指定属性传输的对象\n```\n  <label>用户名：</label><input type=\"text\" name=\"username\">\n  <label>密  码：</label><input type=\"password\" name=\"password\">\n  <label>书籍1：</label><input type=\"text\" name=\"booklist[0]\">\n  <label>书籍2：</label><input type=\"text\" name=\"booklist[1]\">\n  <label>书籍3：</label><input type=\"text\" name=\"booklist[2]\">  //user对象里面设置List集合接收\n```\n```\npublic class hwaction extends ActionSupport implements ModelDriven<user> {  //泛型定义需要赋值转换的类\n    private user us = new user();  \\\\不需要getter setter...\n    public String login(){\nSystem.out.println(us.getUsername());\n System.out.println(us.getBooklist().get(2));\nSystem.out.println(us.getBooklist().get(1));\nSystem.out.println(us.getBooklist().get(0));\n        return SUCCESS;}\n     @Override\n    public user getModel() { \n        return us; //返回需要转换的对象 }}  \n```\n+ 方法四：使用request方法接受 \n\n###处理结果类型\n+ 处理结果标签里面：type属性，默认(dispatcher)是定义jsp模板，还有其他的xstl,chain,redirect,stream,plaintext....\n+ 五个系统内置属性：success，none，error，login，input\n+ success：正确执行完成，返回响应的视图\n+ none：正确执行，但是不返回视图\n+ error：执行失败，返回到错误处理视图\n+ login：由于用户没有登陆的原因没有正确执行，将返回登陆视图，要求用户进行登陆身份验证\n+ input：Action的执行需要前端界面获取参数，input就是代表这个参数的输入界面\n\t+ 表单验证的出现类型转换错误的时候会跳转回去\n\t+ 在判断验证部分使用`this.addFieldError(\"username\",\"用户名不为空\")`，使用`return input;`跳转，并在前端部分使用struts标签显示username的提示\n\t+ 继承ActionSupport里面的Validate()方法，也可以实现跳转\n ### 根据位置不同来划分处理结果类型：\n + 局部结果\n + 全局结果：所有的包下面的请求都可以公用其中返回功能\n\n","tags":["struts2"]},{"title":"比较http请求方法中的GET与POST方法","url":"/archives/4ac038bf.html","content":"#### GET方法和POST方法的异同\n+ GET方法：向页面请求发送已编码的用户信息；页面与已编码信息之间用`?`隔开传递:`http://localhost/test?key1=value&key2=value2`\n    + GET方法的特点是将需要传递信息暴露在URL上面，因此不宜传输敏信息\n    + 同时，GET方法有大小限制：请求字符串最多只能有1024个字符\n+ POST方法：通过比较可靠的方式向后台程序传递数据；但是在传递方式上与GET方法不同，POST方法是通过标准输的形式将一个单独的消息传递给后台程序\n#### 在后台程序中读取传递过来的数据\n+ 解析方法：\n    + String getParameter(String str); 获取表单参数值\n    + String[] getParameterValues(String str); 获取在同一个参数里多个值,并以数组形式返\n    + String[] getParameterNames();获取请求中所有参数的完整列表\n","tags":["Servlet","Web"]},{"title":"Spring MVC常用的控制器方法与使用","url":"/archives/86b8ba8f.html","content":"## Spring mvc 控制器与方法\n#### @Controller定义一个Controller控制器\n+ 在使用这个标记主注解之前需要配置控制器(两种方法)\t\n\t+ 在Spring MVC配置文件中添加`<bean>`对象：`<bean class=\"xyz.royleo.vice\"/>`\n\t+ 在spring配置文件中@Controller控制器的位置：\n```\n< context:component-scan base-package = \"com.host.app.web.controller\" >  \n   < context:exclude-filter type = \"annotation\"  \n       expression = \"org.springframework.stereotype.Service\" />  \n</ context:component-scan >  \n```\n#### @RequestMapping来映射Request请求与控制器\n+ 通过URL模板实现 : 在URL模板中含有变量值,再在`@requestMapping`的方法里面，通过`@PathVariable`获取通过RUL传过来的值\n```\n@Controller  \n@RequestMapping ( \"/test/{variable1}\" )  \npublic class MyController {  \n    @RequestMapping ( \"/showView/{variable2}\" )  \n    public ModelAndView showView( @PathVariable String variable1, @PathVariable ( \"variable2\" ) int variable2) {  \n\t\t//do something \n       return modelAndView;  \n    }  \n}   \n```\n+ 使用`@RequestParam`绑定HttpServletRequest请求参数到控制器方法参数\n\t+ 其中，有requested=false是可选的参数，默认是必须的\n```\n@RequestMapping ( \"requestParam\" )  \nublic String testRequestParam( @RequestParam(required=false) String name, @RequestParam ( \"age\" ) int age) {  \n   return \"requestParam\" ;  \n}  \n```\n\n#### HttpServletRequest & HttpServletResponse & HttpSession...\n+ 跟普通的Servlet一样，spring mvc中也可以用servlet里面的方法\n```\n@RequestMapping(\"/somePath\")\n   public String requestResponseExample(HttpServletRequest request, HttpServletResponse reponses, HttpSession session, Model model) {\n\t // Todo something here\n       return \"someView\";\n   }\n```\n#### 控制器的重定向\n+ 使用前缀：`redirect`该方法返回字符串，可以重定向到另一页面\n```\n@RequestMapping(value = \"/redirect\", method = RequestMethod.GET)\n    public String authorInfo(Model model) {\n\t // Do somethong here\n\t  return \"redirect:/hello\";\n    }\n```\n#### 使用`@CookieValue`绑定cookie数值到Controller方法参数\n```\n    @RequestMapping ( \"cookieValue\" )\n    public String testCookieValue( @CookieValue ( \"hello\" ) String cookieValue, @CookieValue String hello) {\n\t    //do something\n       return \"cookieValue\" ;\n    } \n```\n#### 使用`@RequestHeader`注解绑定HttpServletRequest头信息到Controller方法参数\n```\n@RequestMapping ( \"testRequestHeader\" )\npublic String testRequestHeader( @RequestHeader ( \"Host\" ) String hostAddr, @RequestHeader String Host, @RequestHeader String host ) {\n   //use Host... do something\n    return \"requestHeader\" ;\n} \n```\n#### `@RequestMapping`的一些高级应用\n+ RequestMapping除了指定的路径value值之外，还有其他的一些属性，如：params，method，headers等,便于缩小映射范围\n+ `params`属性：\n\t+ 例子说明：代码中定义了映射的路径，params的三个参数，当映射路径`/testParams.do`并且满足params的规则(param1等于value1，param2必须存在，值无所谓，param3必须不存在)，才能正确映射到testParams()方法. 即：`/testParams.do?param2=value&param2=value2`才能访问指定方法\n```\n@RequestMapping (value= \"testParams\" , params={ \"param1=value1\" , \"param2\" , \"!param3\" })  \npublic String testParams() {  \n   System. out .println( \"test Params...........\" );  \n   return \"testParams\" ;  \n}  \n```\n+ method属性:主要用于限制能访问的方法类型(GET,POST,DELETE...)\n```\n@RequestMapping (value= \"testMethod\" , method={RequestMethod. GET , RequestMethod. DELETE })  \npublic String testMethod() {  \n   return \"method\" ;  \n}   \n```\n+ `headers`属性\n\t+ headers 属性的用法和功能与params 属性相似。在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法。\n```\n@RequestMapping (value= \"testHeaders\" , headers={ \"host=localhost\" , \"Accept\" })  \npublic String testHeaders() {  \n   return \"headers\" ;  \n}   \n```\n#### 以 @RequestMapping 标记的处理器方法支持的方法参数和返回类型\n+ 支持的方法参数类型\n\t+ HttpServlet对象：HttpServletRequest、HttpServletResponse、HttpSession\n\t+ Spring自己的WebRequest对象\n\t+ InputStream、OutputStream、read、write\n\t+ 使用 @pathVariable @RequestParam @CookieValue @RequestHeader 标记的参数\n\t+ 使用 @ModelAttribute 标记的参数\n\t+ java.util.Map 、Spring 封装的Model 和ModelMap：用来展现视图\n\t+ 实体类\n\t+ Spring封装的MutipartFile,用来上传文件\n\t+ Spring 封装的Errors 和BindingResult 对象\n+ 支持的返回类型\n\t+ 一个包含模型和视图的ModelAndView 对象\n\t+ 一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定\n\t+ 一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值\n\t+ 一个String字符串、返回JSON对象(主要是Restful风格，前后端通信)\n\t+ 返回值是void：主要方法体接受传值，执行相关逻辑，返回值可以忽略\n\t+ 如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理\n\t+ 除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行\n#### 使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据\n+ @ModelAttribute标记一般放在需要标记的上面，并指定相关值，当@RequestMapping调用属性参数获取的时候执行\n+ @SessionAttribute 标记一般放在@RequestMapping注解的下面，类名的上面。被@SessionAttribute标记的参数的数值需要被添加到Session中之后，在读取出来之后才有内容；当然，添加的标记的参数类型可以是字符串，数组，实体对象等\n\n","tags":["Spring"]},{"title":"AngularJS 核心特性","url":"/archives/5b142d5f.html","content":"+ MVC : Model - View - Controller\n\t+ 切分代码职责\n\t+ 更好的复用代码\n\t+ 便于模块化管理\n\t+ 终极目标：实现模块化，复用\n+ 模块化Module：一起都是从模块开始，其他都是在module的基础上调用\n+ 指令系统 \n```\nangular.module(\"mymodule\",[]).directive(\"hello\",function(){\n\treturn {\n\t\trestrict: \"E\",\n\t\ttemplate: '<div>Hi everyone</div>'\n\t\treplace: true\n\t}\n})\n```\n+ 双向数据绑定\n\t+ 单向数据绑定：先定义好模板跟数据结合，通过数据绑定机制，将模板跟数据生成一段html标签，再把生成的HTML标签加入到文档流中，但是当数据变化的时候，再去改变view页面的数据，复杂度高；并且view中的数据变换(输入)的时候，无法将改变传回来给model数据\n![单向数据绑定](http://aliosw.oss-cn-hangzhou.aliyuncs.com/%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png)\n\t+ 双向数据绑定：view中的数据变化的时候，数据模型发生变化，当model中的数据发生变化的时候，其中改变能直接反馈给view页面\n![双向数据绑定](http://aliosw.oss-cn-hangzhou.aliyuncs.com/%E5%8F%8C%E5%90%91.png)\n","tags":["Angular JS"]},{"title":"Spring-MVC请求处理工作流程","url":"/archives/5a644a79.html","content":"## 前言\n+ Spring Web MVC框架提供了model-view-controller 的体系结构，可以用来开发灵活的，借助spring的AOP特性，实现松耦合的Web应用程序组件；\n+ MVC模式导致了应用程序不同方面的分离(输入业务、逻辑业务和UI逻辑)，同时提供了这些元素之间的松散耦合\n\t+ Model：封装应用程序数据，并且通常由POJO组成\n\t+ View: 主要用于呈现模型数据，并且由它生成客户端浏览器能够解析的HTML输出\n\t+ Controller：主要用于处理客户请求，并且构建合适的模型，并传递给视图呈现\n\n## DispatcherServlet\n+ Spring MVC框架中，DispatcherServlet用来处理所有的HTTP请求和响应\n#### 工作流程如下：\n![DispatcherServlet](http://aliosw.oss-cn-hangzhou.aliyuncs.com/mvc1.png)\n#### 当请求触发的时候...\n+ 收到一个HTTP请求之后，DispatcherServlet根据HandlerMapping来选择并且调用适当的控制器\n+ 控制器接受请求，并基于使用GET或者POST方法来调用适当的Service方法。Service方法将设置基于定义业务逻辑的数据模型，并返回视图名称到DispatcherServlet中\n+ DispatcherServlet在ViewResolver的协助下，检索获取指定的视图\n+ 当视图确定之后，DispatcherServlet把模型数据传递给视图，最后在浏览器中呈现\n## 部分配置以及代码说明\n+ 初始化DispatcherServlet,导入Servlet-Name的应用配置文件`{servlet-name}-servlet.xml`\n```\n<servlet>\n      <servlet-name>HelloWeb</servlet-name>\n      <servlet-class>\n         org.springframework.web.servlet.DispatcherServlet\n      </servlet-class>\n      <load-on-startup>1</load-on-startup>\n   </servlet>\n```\n+ 定义处理的URL类型(对应servlet-name)\n```\n<servlet-mapping>\n      <servlet-name>HelloWeb</servlet-name>\n      <url-pattern>*.jsp</url-pattern>\n   </servlet-mapping>\n```\n+ 定义视图解决方案\n```\n<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n      <property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\n      <property name=\"suffix\" value=\".jsp\" />\t//收到DispatcherServlet返回的视图名称之后，显示`[viewName].jsp`文件\n   </bean>\n```\n+ 定义控制器\n```\n@Controller\n@RequestMapping(\"/hello\")  //url路径\npublic class HelloController{\n   @RequestMapping(method = RequestMethod.GET) \t\t//使用GET方法\n   public String printHello(ModelMap model) {\n      model.addAttribute(\"message\", \"Hello Spring MVC Framework!\"); \t//绑定Message属性的值，并传递给DispatcherServlet\n      return \"viewName\";  \t\t//返回给DispatcherServlet的视图名称\n   }\n}\n```\n+ 视图,下例是一个jsp文件的部分代码，message是在控制器内部设置的属性\n```\n<html>\n   <head>\n   <title>Hello Spring MVC</title>\n   </head>\n   <body>\n   <h2>${message}</h2>\n   </body>\n</html>\n```\n## 拓展\n+ 目前流行的Restful风格的设计，可以借助Spring-MVC实现，更好的实现前后端分离，控制器之间通过DispatcherServlet，给View页面传递一组 JSON 或者是 XML 等形式的数据，view接受到数据之后，通过Angular JS /reaact等其他一些Javascript的一些单页框架，处理后端传过来的数据，并显示出来.\n","tags":["Spring"]},{"title":"Angular JS 基础笔记","url":"/archives/897c0a7c.html","content":"## AngularJS 开发\n+ 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。\n+ Angular JS 把应用程序数据绑定到HTML元素\n+ Angular JS 可以克隆和重复HTML元素\n+ Angular JS 可以隐藏/显示HTML元素\n+ Angular JS 可以在元素背后添加代码\n+ Angular JS 支持输入验证\n\n## $scope 作用域\n+ $scope 对象当作一个参数传递\n+ 带有属性和方法，这些属性和方法可以在视图和控制器中使用\n+ 根作用域`$rootScope`: 可作用于整个应用中。是各个 controller 中 scope 的桥梁。用 rootscope 定义的值，可以在各个 controller 中使用。\n\n## Angular JS 服务\n+ $location : 返回当前页面的 URL 地址 ($location.absUrl();)\n+ $http :(例子)\n```\nvar app = angular.module('myApp', []);\napp.controller('myCtrl', function($scope, $http) {\n    $http.get(\"welcome.htm\").then(function (response) {\n        $scope.myWelcome = response.data;\n    });\n});\n```\n+  $timeout 访问在规定的毫秒数后执行指定函数\n```\n$timeout(function () {\n      $scope.myHeader = \"How are you today?\";\n  }, 2000);\n```\n+ $interval 访问在指定的周期(以毫秒计)来调用函数或计算表达式\n```\n $interval(function () {\n      $scope.theTime = new Date().toLocaleTimeString();\n  }, 1000);\n```\n+ 创建自定义服务\n```\napp.service('hexafy', function() {\n    this.myFunc = function (x) {\n        return x.toString(16);\n    }\n});\n```\n+ 使用自定义服务\n```\napp.controller('myCtrl', function($scope, hexafy) {\n    $scope.hex = hexafy.myFunc(255);\n}); //不加`$`区分自带和自定义服务\n```\n\n\n\n## Angular JS 指令\n+ ng-app 指令初始化一个AngularJS应用程序\n+ ng-init 初始化一个应用程序数据\n+ ng-model 把元素值(比如输入域的值)绑定到应用程序中\n+ ng-repeat 指令会重复一个HTML元素\n```\n<div ng-app=\"\" ng-init=\"names=['Jani','Hege','dasd'];in=100\">\n  <p>使用 ng-repeat 来循环数组</p>\n\t<input type=number ng-model=\"in\" >\n  <ul>\n    <li ng-repeat=\"x in names\">\n      {{ x }}\n    </li>\n\t  <li>{{in}}</li>\n  </ul>\n</div>\n```\n+ ng-disabled : 直接绑定应用程序数据到HTML的disabled属性 ; 当 标记记作 `true` 被标记的元素失效\n```\n<button ng-disabled=\"mySwitch\">点我!</button>\n<input type=\"checkbox\" ng-model=\"mySwitch\">\n```\n+ ng-show : 被标记元素标记为true时，改元素可见\n+ ng-hide :  true ---> 不可见\n\n## Angular JS 事件\n+ ng-click : 定义ng的点击触发事件\n___\n## 未完待续......\n\n","tags":["Angular JS"]},{"title":"hibernate实现原理与思考","url":"/archives/7ae62b4c.html","content":"#### hibernate概述(参考[Wikipedia](https://zh.wikipedia.org/wiki/Hibernate))\n+ hibernate是一种Java语言下对象关系映射(ORM)解决方案；\n+ 设计目标是将软件开发人员从大量相同的数据持久层相关编程工作中解放出来\n+ hibernate可以想象成为一个中间组件；当Java通过SQL连接数据库的时候，hibernate负责将java程序的SQL语句接受过来发送带数据库处理，而数据库返回的数据，hibernate接受之后直接生成对象的形式传递给Java程序\n___\n#### 以一次数据库操作为例，分析hibernate实现原理.\n+ 当SQL语句能正常执行：`select * from user;`\n+ 项目启动时候，hibernate配置文件(`*.cfg.xml` & `user.hbm.xml`) 中的内容已经配置好在容器中，存储着实体类(`User`)与表的对应关系\n+ 执行hql语句的时候，hibernate会根据反射机制先找到User的全路径名称，进而找到容器中User对应的配置\n+ 由于对象的实体属性与表中的属性一一对应，hibernate会将HQL语句，根据不同的数据库方言解析为SQL语句，并在数据库中执行语句\n___\n#### 总的来说：\n+ hibernate是将实体类中的字段按照`*.hbm.xml`配置文件或者是annotation的注释标记来解析一条或者多条sql语句，然后放在数据库中执行\n1. 通过`configuration().configure();`读取并解析hibernate.cfg.xml配置文件\n2. 执行完`hibernate.cfg.xml`的基本数据库映射配置之后，再通过配置文件中的 mapping 标记，解析并读取映射信息\n3. `config.biuldSessionFactory();`创建SessionFactory;\n4. `SessionFactory.open();` 打开Session\n5. `session.beginTransaction();`创建事务\n6. persistent operate 持久化操作\n7. `session.getTransaction().commit();`提交事务\n8. `session.getTransaction.rollback();`事务提交出错的时候，回滚事务\n9. `session.close();`关闭事务\n10. `SessionFactory.close();`\n\n+ 这就是hibernate的原理(也可以叫流程)：基于一个ORM的主流持久化框架，对JDBC访问数据库代买进行了封装\n___\n####思考：\n+ 昨天去了某厂面试，当面试官问我hibernate知不知道hibernate底层原理的时候,我说了不了解....\n+ 因为在这个问题之前我就是已经简单的描述了hibernate的流程，当我听到底层原理的时候，及懵逼了，用了hibernate这么久，还真好像没看到过hibernate的底层原理的描述...\n+ 回来查了一下,其实就是详细的描述hibernate流程...\n+ 面试的时候，由于是第一次面试，紧张！还没适应面试的过程是怎么样的，应聘者应该如果主动的跟面试官沟通，如果将自己的能力以及个性给面试官展现出来...\n+ 又是一次新鲜的经历，在各种经历中成长 @.@\n","tags":["Hibernate"]},{"title":"Mysql管理用户操作(创建用户，删除用户，修改用户密码，权限分配以及相关授权)","url":"/archives/8314bbf6.html","content":"#### 创建mysql用户\n+ 创建用户设定密码：\n  `create user 'username' identified by 'password';`\n+ 创建用户，密码，并绑定登陆IP(ip:%表示所有IP，也可以限制为网段[231.23.2.%])\n  `create user 'username'@'ip' identified by 'password'`\n+ 使操作生效：`flush privileges`\n\n#### 为用户授权\n+ 将用户所有的权限绑定到某个数据库：\n  `grant all privileges on basename(*).tablename(*) to username@localhost`\n+ 或者只授予用户指定的权限：`insert` `delete` `update` `select`...\n  `grant insert,select,update,delete on *.* to user@localhost`\n\n#### 撤销用户权限\n+ 格式：`revoke 权限 on 库名.表名 from 用户名@用户地址;`\n\n#### 删除用户\n+ 直接删除用户：`drop user`(将用户信息全部删除)\n```\n>drop user test1@'%';\n>flush privileges;   \n```\n+ 删除用户：`delete from user`(只会清除对应user创建的表)\n```\n>use mysql;\n>delete from user where user=test1 and host='%';\n>flush privileges;\n```\n#### 修改指定用户的密码(也就是更新mysql库下user的表)\n```\n>>update mysql.user set password=password('新密码') where  user=\"test2\" and host=\"%\";\n>>flush privilieges;\n```\n#### 远程登陆\n```\n>mysql -h 'ip' -u 'username' -p 'ip'  ##个人习惯enter之后输密文password\n```\n#### tips\n+ mysql库下面有几个表，研究清楚了，也就更加了解了mysql的基本操作了\n+ 还有就是，新版本的mysql数据库自动为你创建了几个常用的库跟表，比如'country'等....(然而我很少用)\n","tags":["Mysql"]},{"title":"Hibernate出现Caused by: java.sql.SQLException: Field 'id' doesn't have a default value的解决方法","url":"/archives/faff5c20.html","content":"\n### 原因：设计Mysql的id的时候，id使用主键策略，但是没有设置自动生成造成\n### 解决方案：\n  + 取消主键策略(下下策)；\n  + 更改结构语句：为主键id添加`auto_increment`属性；也就是更改表结构\n","tags":["Hibernate"]},{"title":"关于Maven 打包时 缺失properties和xml后缀的文件","url":"/archives/f8defb4e.html","content":"+ 背景\n  + Intellij IDEA 14.1.5\n  + Maven 项目\n+ 问题\n### 打包Maven项目的时候，报错\n```\nlog4j:WARN No appenders could be found for logger (logmain).\nlog4j:WARN Please initialize the log4j system properly.\nlog4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.\n```\n### 但是我的目录下有`log4j.properties`配置文件\n### 展开才发现：输出的类没有'log4j.properties'配置文件\n## 解决方案\n+ 在pom中添加resources配置\n```\n<build>\n        <resources>\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.properties</include>\n                </includes>\n            </resource>\n        </resources>\n    </build>\n```\n## 说明\n+ Maven的生命周期：\n\n|生命周期阶段|目标|\n|---|---|\n|process-resources|resources:resources|\n|compile|compile:compile|\n|process-test-resources|resources:testResource|\n|test-compile|compile:testCompile|\n|test|surefire:test|\n|package|war:war|\n|install|install:install|\n|deploy|deploy:deploy|\n+ 经测试\n\n  1. 当pom中不增加resources配置时，\n执行process-resources，class文件夹下只包含src/main/resources下的文件\n执行compile，class文件夹下包含src/main/resources下的文件与src/main/java下的*.class文件，丢失src/main/java下的*.properties文件\n  2. 当pom中增加resources配置时\n执行process-resources，class文件夹下只包含src/main/resources下的文件与src/main/java下的*.properties文件\n执行compile，class文件夹下包含src/main/resources下的文件与src/main/java下的*.class文件与*.properties文件\n\n### 同样，对于maven项目加载不出来`xml`文件的情况，解决方法类似\n\n\n```\n<build>\n        <resources>\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.xml</include>\n                </includes>\n            </resource>\n        </resources>\n</build>```\n","tags":["Maven"]},{"title":"无法连接远程Mysql数据库的解决办法 I","url":"/archives/b4e8978.html","content":"## tips: \"Can not connet to mysql  server on '192.168.2.3' (10061)\"\n+ 很多时候想要远程登陆Mysql服务器，进行操作，发现弹出上面的提示...\n## 解决方案：\n  + 可能没有启动Mysql服务：`/etc/init.d/mysql start` 启动服务\n  + 查看配置文件 `/etc/mysql/my.cnf` 文件中绑定的ip地址是否为默认ip(127.0.0.1)\n```\nroot@ubuntu: vim /etc/mysql/my.cnf\nroot@ubuntu:                      #修改my.cnf的文件里面的配置\n修改 bind-adress = 127.0.0.1\n为 bind-adress = 服务器IP\n#这种情况最显著的现象是：远程登陆不上Mysql服务器，但是服务器本地能登陆进去mysql程序\n```\n  + 检查或者重置my.ini配置文件是否正确\n  + Mysql服务器连接池已满，重新释放一下连接池，这时候你要重新评估你的连接数或者检测是否有恶意访问攻击什么的\n\n\n---\n  如果找partner，要物色好可靠的人选；不然，两人的价值观不一样，做事情的效率跟质量都不一样。\n","tags":["Mysql","TakeDown"]},{"title":"Java垃圾回收之finalize()","url":"/archives/db1953ee.html","content":"## Java垃圾回收\n+ Java垃圾回收器负责回收无用对象占据的内存资源\n+ 但是，无论是“垃圾回收”或者“终结”，JVM都不保证会发生，因为JVM在没有面临内存耗尽的情况下，它是不会浪费时间去执行垃圾回收以恢复内存\n+ JVM不会主动去发现一些无用特殊的内存区块，并清除它，所以引入`finalize()`方法\n\n## `finalize()`用法\n+ 对象可能不被垃圾回收\n+ 垃圾回收并不等于“析构”\n+ 垃圾回收只与内存有关\n\n##### `finalize()`工作原理\n+ 一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用`finalize()`方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存\n\n#### 下面一个例子示范`finalize()`可能的使用方式(终结条件)\n```\nclass Book{\n  boolean checkedOut = false;\n  Book(boolean checkOut){\n    checkedOut = checkOut;\n  }\n  void chechIn(){\n    checkedOut = false;\n  }\n  protected void finalize(){\n    if(checkedOut){\n      System.out.print(\"error:check out\");\n    }\n  }\n}\npublic class Terminal{\n  public static void main(String[] args){\n    Book novel = new Book(true);\n    novel.chechIn();\n    new Book(true);\n    System.gc();\n  }\n}\n/*\n*output:\n*error:check out\n*/\n```\n###### 本例的终结条件：所有的Book对象在被当作垃圾回收前都应该被签入(chechIn);但是`main()`方法中，有一本书没被签入，所以如果没有`finalize()`来验证终结条件，那么这个缺陷很难被发现.\n"},{"title":"Java常识之构造器","url":"/archives/57584ce4.html","content":"## 构造器确保初始化\n+ 创建对象时，会为对象分配存储空间，并调用相应的构造器，这样就确保了你操作对象之前，它已经被初始化；\n+ 如果类中没有定义构造器，编译器会自动帮你创建一个默认构造器，当你定义了构造器，就不能使用默认构造器;\n+ 要求构造器的名字与类名一致，可以有多个构造器，但是每个构造器要有区分(有参数\\无参数\\参数顺序\\参数类型)\n```\nclass Rock{\n  Rock(){\n    System.out.print(\"Constructor Initialize\")\n  }\n  public static void main(String[] args){\n    for(int i = 0; i < 5 ; i++ ){\n      new Rock();\n    }\n  }\n}\n```\n\n## 方法重载\n+ 一个类中，可以有相同的命名的方法，但是这些方法需要有区分\n+ 区分重载方法：\n  + 是否有参数;\n  + 参数的顺序;\n  + 参数的类型;\n    + 当传入的实际参数小于重载方法声明的形式参数时，实际数据类型就会被提升，而实际参数是char型，如果无法找到插好接受char参数的方法，就会把char型提升到int型;\n    + 当传入的实际参数大于重载方法声明的形式参数时，实际参数需要进行类型转换来窄化转换，否则会报错;\n\n##### Best Wish : Happy Mathors Day! To My Mon .\n","tags":["Java"]},{"title":"在Github创建静态网站预览的方法","url":"/archives/a9d721e9.html","content":"+ 前段时间参加了百度前端学院的前端学习，想着不用把别人前端页面代码下载下来就能预览的话，就方便多了，既能看代码，又能看到效果，还可以用chrome调试\n___\n## 正文\n+ 方法一：通过第三方开源项目预览\n  + 访问`http://htmlpreview.github.io/`[enter link description here](http://htmlpreview.github.io/) 填写你要预览的页面地址，Enter-->Get\n  + 得到这样格式的访问连接：`http://htmlpreview.github.io/?https://github.com/liangqian/ifeFPGetting/blob/master/Part1/task_01_01_01.html` 也就是 ：`http://htmlpreview.github.io/?`+目标预览页面地址\n+ 方法二：创建gh-pages分支进行预览\n  + 创建gh-pages分支进行预览，创建分支之后，访问`http://你的Github名.github.io/`+页面地址\n  例如：liangqian.github.io/preview/test.html\n  + 这是官方的推荐方法 [enter link description here](https://help.github.com/articles/creating-project-pages-manually/)\n","tags":["Git","TakeDown"]}]