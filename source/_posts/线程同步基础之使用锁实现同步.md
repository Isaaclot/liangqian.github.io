---
title: 线程同步基础之使用锁实现同步
date: 2016-10-16 22:38:51
tags: [Java,《Java 7并发编程实战手册》读书笔记]

---
## 线程同步基础之使用锁实现同步
#### 概述
+ 使用锁实现同步是通过重写Lock接口来实现，与synchronized相比，Lock接口允许实现更复杂的临界区结构(控制的获取和释放不在同一个块结构中)

#### 死锁
+ 定义：当两个或者多个线程被阻塞并且他们等待释放的锁永远都不会是释放，就会发生死锁

#### 使用实例
+ Lock接口引入`tryLock()`方法获取锁，如果锁已经被其他线程获取，那就返回false，并继续往下执行代码(不是执行临界区代码，而且相当于事物回滚的机制)
+ 使用`lock()`方法获取对锁的控制，必须也用`unlock()`释放对锁的控制
```
public void printJob(Object doc){
        queueLock.lock();
        try {
            long duration = (long) (Math.random()*10000);
            System.out.println(Thread.currentThread().getName()+" OrintQueue Printing a job during "+(duration/1000)+"second");
            Thread.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            queueLock.unlock();
        }
    }
```

#### 使用读写锁实现同步数据的访问
+ `ReadWriteLock`接口和他的实现类`ReenteantReadWriteLock`。这两个类有两个锁，一个是读操作锁(可同时允许多个人访问)，一个是写操作锁(同一时段只能一个线程操作)
```
public double getPrice2(){
        lock.readLock().lock();
        double value = price2;
        lock.readLock().unlock();
        return value;
    }

    public void setPrice1(double price1,double price2){
        lock.writeLock().lock();
        this.price2=price2;
        this.price1=price1;
        lock.writeLock().unlock();
    }
```
