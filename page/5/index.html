<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 5 页 | 哈姆雷特1001</title>
  <meta name="author" content="Rico Nut">
  
  <meta name="description" content="学习总结 思考感悟 知识管理">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="哈姆雷特1001"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/cerulean.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  



</head>

<body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">哈姆雷特1001</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
    <div class="content">
      <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">哈姆雷特1001</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      Stay Hungry.
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-09-08 </div>
			<div class="article-title"><a href="/archives/4be26d16.html" title="V2ray必要的使用说明">v2ray_科学手段</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="For-Windows"><a href="#For-Windows" class="headerlink" title="For Windows"></a>For Windows</h4><ul>
<li>下载<ol>
<li><a href="http://qvm.lays3721.top/v2rayn_v2.14_win32.zip" target="_blank" rel="noopener">Win32</a></li>
<li><a href="http://qvm.lays3721.top/v2rayn_v2.14_win64.zip" target="_blank" rel="noopener">Win64</a></li>
</ol>
</li>
<li>安装<ol>
<li>安装 解压后，双击文件夹内的 V2RayN.exe 即可运行，如闪退请确认电脑系统是否缺少.NET 4.5（最低 4.5）</li>
<li><img src="http://qvm.lays3721.top/v2ray_forwin.gif" alt="安装/运行"></li>
</ol>
</li>
<li>配置<ol>
<li>账户导入：导入账号的方法有很多种，比如从剪切板导入批量 URL、扫描屏幕二维码、手动填写账号信息和导入配置文件等，前两个方法在 PC 端最为常用。</li>
<li>例如：<img src="http://qvm.lays3721.top/v2ray_win_config.gif" alt="剪切板导入"></li>
<li>如上图所示，先复制 V2Ray 账号 URL，在右键点击屏幕右下角 V2RayN 图标，选择从剪切板导入批量 URL，点击弹出的确认按钮即可；扫描屏幕二维码的导入方式也很好理解，在电脑屏幕上打开 V2Ray 账号的二维码图片，右键点击屏幕右下角 V2RayN 图标，选择扫描屏幕二维码。</li>
<li>V2rayn算是局部代理，可以选择配合chrome插件试用，比如： SwitchyOmega等，SwitchyOmega配置可先自行搜索，如果必要，后面再补上</li>
<li>必要配置：<br><img src="http://qvm.lays3721.top/v2ray_for_mac_%E5%BF%85%E8%A6%81%E8%AE%BE%E7%BD%AE.gif" alt="配置"><h4 id="For-Android-BifrostV"><a href="#For-Android-BifrostV" class="headerlink" title="For Android(BifrostV)"></a>For Android(BifrostV)</h4></li>
</ol>
</li>
<li>下载链接<ul>
<li><a href="http://qvm.lays3721.top/Bifrostv_v0.5.16_newfgq.com.apk" target="_blank" rel="noopener">BifrostV</a></li>
</ul>
</li>
<li>配置<ol>
<li>可选择手动配置，导入配置，扫描二维码形式配置等，如使用过ss/ssr客户端的用户，操作步骤基本一样，可操作性强</li>
<li>上图：<br><img src="http://qvm.lays3721.top/bifv_page_1.png" alt="BifrostV 页面"><br><img src="http://qvm.lays3721.top/brfg_p_2.png" alt="添加账号"><br><img src="http://qvm.lays3721.top/bifg_p3.png" alt="账号设置"></li>
</ol>
</li>
</ul>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><ul>
<li>此文仅用于学习研究试用，仅做笔记整理，如有其他用途，与本站无关</li>
</ul>

	
	</div>
  <a type="button" href="/archives/4be26d16.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-08-16 </div>
			<div class="article-title"><a href="/archives/861d9c25.html" >原生JDBC操作数据库的思考总结</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>相信很多java工程师在入门Java操作数据库的时候，都是首先接触到JDBC连接数据库的方式访问操作数据库，对数据库进行增删查改(CRUD)</li>
<li>但是久而久之，基于各种原因(团队\需求)，后来就使用封装了JDBC的框架来访问数据库，比如<code>hibernate</code>,<code>Mybatis\iBats</code>,我这里总结一下一些关于使用原生JDBC操作数据库的一些思考</li>
</ul>
<h4 id="JDBC编程步骤"><a href="#JDBC编程步骤" class="headerlink" title="JDBC编程步骤"></a>JDBC编程步骤</h4><ol>
<li>加载数据库驱动</li>
<li>创建并获取数据库链接</li>
<li>创建jdbc statement对象</li>
<li>设置sql语句</li>
<li>社会sql语句中的参数(使用preparedStatement预加载)</li>
<li>通过statement执行sql并获得结果</li>
<li>对sql执行结果进行解析</li>
<li>释放资源关闭数据库</li>
</ol>
<h4 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h4><ol>
<li>数据库链接，使用时就创建，不使用的时候就释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能<br>假想方案：使用数据库连接池管理数据库连接</li>
<li>将sql语句英编码到Java代码中，如果要修改sql语句，需要重新编译Java代码，不利于系统维护<br>假想方案：将sql语句配置在xml配置文件中，需要修改sql语句的时候直接在xml配置文件，不需要重新编译Java代码</li>
<li>向preparedStatement中设置参数，对占位符位置和设置参数值，硬编码到Java代码中，不利于系统维护<br>假想方案：将sql语句以及占位符和参数全在配置文件中定义配置</li>
<li>从resultSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护<br>假想方案：将查询的结果集，自动映射成Java对象</li>
<li>对于繁杂程度来说，要使用一堆编码，才能实现一丢丢的查询……</li>
</ol>

	
	</div>
  <a type="button" href="/archives/861d9c25.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-08-10 </div>
			<div class="article-title"><a href="/archives/bef463.html" title="重定向和请求转发，在web中的应用都不少，但是之间有什么区别？在什么时候应该选择哪种跳转方式？">java 重定向与转发的异同</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h3 id="重定向与请求转发的异同"><a href="#重定向与请求转发的异同" class="headerlink" title="重定向与请求转发的异同"></a>重定向与请求转发的异同</h3><h5 id="同："><a href="#同：" class="headerlink" title="同："></a>同：</h5><ul>
<li>两种方式都能跳转到目标页面</li>
</ul>
<h5 id="异："><a href="#异：" class="headerlink" title="异："></a>异：</h5><ul>
<li><p>本质区别：</p>
<ol>
<li>请求转发是服务器行为，而重定向是客户端行为：<ul>
<li>转发过程：browser http请求—-&gt; web server接受请求—-&gt; 调用内部的一个方法在容器内部完成请求处理和转发 动作—–&gt;将目标资源发生给客户端；转发路径必须经过web容器的url，不能转向到其他的web路径，中间传递的是自的容器内的request. 而在客户端浏览器地址栏显示出来的是第一次访问的路径。也就是说，转发行为是浏览器只做了一次访问请求</li>
<li>重定向过程：browser http请求—-&gt; web server接受后发送302状态码以及对应新的location地址给客户端—-&gt; 客户端发现302状态码，则自动再转发一个新的http请求，请求url是新的location地址 —-&gt;服务器根据此请求寻找资源并发送给客户. 重定向行为是浏览器做了至少两次访问请求.</li>
</ul>
</li>
<li>对于请求次数的解析：<ul>
<li>重定向在客户端 request A ,server响应状态码，指示browser应该访问 B. 这时候可以看到地址栏发生变化。重定向可以访问自己web应用以外的资源，在充定向过程中，传输的信息会丢失</li>
<li>请求转发是在服务器内部一个request/response的处理权移交，对于客户端来说，它只知道自己最早的请求的那个A但是不知道中间其他的访问路径，传输信息不会丢失</li>
</ul>
</li>
</ol>
</li>
<li><p>从数据分享角度：</p>
<ul>
<li>请求转发的转发页面与转发目标页面可以共享request里面的数据</li>
<li>重定向的跳转页面之间不可以共享数据</li>
</ul>
</li>
<li><p>从运用角度：</p>
<ul>
<li>请求转发一般用于用户登录的时候，或者角色转发到响应的模块</li>
<li>重定向一般用于用户注销登陆时返回和跳转到其他网站等</li>
</ul>
</li>
<li><p>从效率角度：</p>
<ul>
<li>请求转发效率比重定向效率高</li>
</ul>
</li>
<li><p>内部实现：</p>
<ul>
<li><p>请求转发部分：servlet主要负责处理具体的请求转发。通过获得RequestDispatcher对象，然后用forward方法进行请求转发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestDisapatcher rd=reqest.getRequestDisapatcher();</span><br><span class="line">rd.forward(req,resp); //用这里的方法来进行转发</span><br></pre></td></tr></table></figure>
</li>
<li><p>sendRedirect方法属于HttpServletResponse对象的getRequestDispatcher方法得到</p>
</li>
</ul>
</li>
</ul>

	
	</div>
  <a type="button" href="/archives/bef463.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-08-01 </div>
			<div class="article-title"><a href="/archives/5574abb0.html" title="TCP连接是在IP网络中两个进程间(应用层协议)的双向、全双工的逻辑回路.由节点的IP地址和端口将连接双方对应起来">TCP通信三次握手协议原理与过程分析</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h3 id="TCP传输标志位解析："><a href="#TCP传输标志位解析：" class="headerlink" title="TCP传输标志位解析："></a>TCP传输标志位解析：</h3><ol>
<li>SYN(synchronous建立联机) ：请求建立连接的数据包</li>
<li>ACK(acknowledgement 确认) ：回应数据包，表示接收到了对方的某个数据包</li>
<li>PSH(push传送) ：正常数据包</li>
<li>FIN(finish结束) ：通讯结束包</li>
<li>RST(reset重置) ：重置连接</li>
<li>URG(urgent紧急) ：紧急指针</li>
<li>Sequence number(顺序号码) </li>
<li>Acknowledge number(确认号码)</li>
</ol>
<h3 id="TCP通信建立连接-三次握手-原理"><a href="#TCP通信建立连接-三次握手-原理" class="headerlink" title="TCP通信建立连接(三次握手)原理"></a>TCP通信建立连接(三次握手)原理</h3><ol>
<li>客户端通过向服务器端发送一个SYN来建立一个主动打开，作为三路握手的一部分</li>
<li>服务器端应当为一个合法的SYN回送一个SYN/ACK</li>
<li>最后，客户端再发送一个ACK，这样三次握手就完成，并进入到建立连接部分</li>
</ol>
<center><br><img src="http://qvm.lays3721.top/tcpbiuld.png" alt="TCPBuild"><br></center>

<h3 id="建立连接过程分析"><a href="#建立连接过程分析" class="headerlink" title="建立连接过程分析"></a>建立连接过程分析</h3><ul>
<li>过程</li>
</ul>
<ol>
<li>第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；</li>
<li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包</li>
<li>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。</li>
</ol>
<ul>
<li><p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: S 3626544836:3626544836</span><br><span class="line"> IP 192.168.1.123.7788 &gt; 192.168.1.116.3337: S 1739326486:1739326486 ack 3626544837</span><br><span class="line"> IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: ack 1739326487,ack 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析：</p>
</li>
</ul>
<ol>
<li>第一次握手：从192.168.1.116的端口3337发送位码syn=1,随机产生seq number=3626544836的数据包到192.168.1.123端口7788由syn=1知道192.168.1.116要求建立联机</li>
<li>第二次握手：192.168.1.123:7788收到请求之后要确认信息，向192.168.1.116:3337发送ack number=3626544837，syn=1，ack=1随机产生seq=1739326486的数据包</li>
<li>192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功</li>
</ol>
<h3 id="TCP连接建立过程为神马需要三次握手？"><a href="#TCP连接建立过程为神马需要三次握手？" class="headerlink" title="TCP连接建立过程为神马需要三次握手？"></a>TCP连接建立过程为神马需要三次握手？</h3><ul>
<li>概述：传输控制协议（Transmission Control Protocol, TCP）是一种面向连接的、可靠的、基于字节流的运输层（Transport layer）通信协议，是专门为了在不可靠的互联网络上提供一个可靠的端到端字节流而设计的</li>
<li>目的：防止已经失效的连接请求突然又传送到服务端，因而产生错误(为了解决网络中存在延迟的重复分组)</li>
<li>例子说明：</li>
</ul>
<ol>
<li>client发出的第一个连接请求报文段并没有消失，而是在网络某个节点上长时间滞留了，以致延误到连接释放以后的某个时间才到达server端. 而这个已经失效已久的连接到达server之后，就误认为是client新建立起来的连接，于是server向client发送数据，但是server却以为新的传输连接已经建立，于是就像client发出确认报文段，同意建立连接。</li>
<li>如果没有三次握手的过程，那么只要server发出确认，新的连接就建立，由于现在client并没有发出建立 连接的请求，因此不会理财server的确认，也不会向server发送数据，但server却以为新的传输连接已经建立，并一直等待client发来数据，这样的话，就会造成资源浪费</li>
<li>而采用三次握手过程，就可以避免上述现象，client不会向server的确认发出确认，server由于收不到确认，就知道client并没有建立连接</li>
</ol>

	
	</div>
  <a type="button" href="/archives/5574abb0.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-07-31 </div>
			<div class="article-title"><a href="/archives/4a1b8e6e.html" title="近年来以信息为中心的表属性状态转移(Respresentational State Transfer REST)已经成为替代传统SOAP　Web服务的流行方案；而且Spring封装对REST的良好支撑">Spring中添加REST功能</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="REST基本原理："><a href="#REST基本原理：" class="headerlink" title="REST基本原理："></a>REST基本原理：</h4><ul>
<li>通过简单的HTTP URL触发事件</li>
<li>REST是将资源最合适地从服务端转移到客户端(或者反之)</li>
<li>REST与RPC(远程过程调用)：REST面向资源，强调描述应用程序的事物和名词;RPC面向服务，关注于行为和行动<h4 id="Spring如何支持REST？"><a href="#Spring如何支持REST？" class="headerlink" title="Spring如何支持REST？"></a>Spring如何支持REST？</h4></li>
<li>控制器可以处理所有的HTTP方法：GET、POST、DELETE、PUT…</li>
<li>@PathVariable 注解使控制器能够处理参数化的URL(带参数变量的URL)</li>
<li>Spring表单绑定JSP标签库的<code>&lt;form:form&gt;</code>标签以及新的HidenHttpMethodFilter，使得通过HTML转发提交的PUT，DELETE请求成为可能(即使mou’xie)</li>
<li>使用String的视图和视图解析器，资源可以以各种形式表述，包括将数据模型表示为：XML、JSON、ATOM、RSS等</li>
<li>使用新的ContentNegotiatingResolver来选择合适的客户端表述</li>
<li>类似的，使用@ResponseBody注解以及HttpMethodConverter实现可以将传入的HTTP数据转化为传入控制器的处理方法的Java对象</li>
<li>RestTemplate简化客户端对REST资源的使用</li>
</ul>
<h4 id="RESTful-URL"><a href="#RESTful-URL" class="headerlink" title="RESTful URL"></a>RESTful URL</h4><ul>
<li>格式：<code>http://localhost:8080/spitter/spittles/123</code><ul>
<li>协议：//域名：端口号/Servlet上下文路径/资源类型/特定的spittle</li>
<li>REST　URL是用来标识资源</li>
</ul>
</li>
<li>RESTful　URL是有层级结构的，每个层标识一种资源</li>
<li>其中，URL还可以参数化，在控制器中获取该参数<code>@PathVariable(&quot;id&quot;) long id</code></li>
</ul>
<h4 id="执行REST动作"><a href="#执行REST动作" class="headerlink" title="执行REST动作"></a>执行REST动作</h4><ul>
<li>HTTP提供来操作资源的方法，主要是四个</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>是否安全</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>从服务器上检索资源信息，资源通过请求的URL来进行标识</td>
<td>是</td>
</tr>
<tr>
<td>POST</td>
<td>传送数据到服务器，数据会由监听该请求的URL处理器进行处理</td>
<td>否</td>
</tr>
<tr>
<td>PUT</td>
<td>按照请求的URＬ，防治资源到服务器指定位置</td>
<td>否</td>
</tr>
<tr>
<td>DELETE</td>
<td>将请求URL标识的资源从服务器上删除</td>
<td>否</td>
</tr>
</tbody>
</table>
<h4 id="表述资源"><a href="#表述资源" class="headerlink" title="表述资源"></a>表述资源</h4><ul>
<li>Spring提供两种形式，将资源的Java表述形式转换为发送给客户端的表述形式：<ul>
<li>基于视图渲染进行协商</li>
<li>HTTP消息转换器</li>
</ul>
</li>
<li>协商资源表述<br>bean配置:<figure class="highlight plain"><figcaption><span>根据客户端的不同的请求决定不同的view进行响应, 如/blog/1.json/blog/1.xml--></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;</span><br><span class="line">&lt;!-- 设置为true以忽略对Accept Header的支持--&gt;</span><br><span class="line">         ##&lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;/&gt;</span><br><span class="line"> &lt;!-- 在没有扩展名时即: &quot;/user/1&quot; 时的默认展现形式 --&gt;</span><br><span class="line">        &lt;property name=&quot;defaultContentType&quot; value=&quot;text/html&quot;/&gt;</span><br><span class="line">&lt;!-- 扩展名至mimeType的映射,即 /user.json =&gt; application/json --&gt;</span><br><span class="line">        &lt;property name=&quot;mediaTypes&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt;</span><br><span class="line">                &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>确定请求的媒体类型<ul>
<li>ViewResolver首先查找URL中的文件扩展名，将文件扩展名与mediatype的条目匹配，如果找到匹配项，则使用该媒体类型，并覆盖accpt头信息中的任何媒体类型</li>
<li>如果找不到URL中的扩展名，那么就使用Accept中的头信息的媒体类型</li>
<li>如果请求头中不包含Accept头信息，那么就使用defaultContentType属性中设置的媒体类型</li>
</ul>
</li>
<li>影响如何选择类型<ul>
<li>将favorPathExtension属性设置为false，将会使得ContextNegotiatingViewResolver忽略URL路径扩展名</li>
<li>将JAF添加到类路径下将会使得ContextNegotiatingViewResolver除了使用mediaTypes属性中的条目外，在路径扩展名确定媒体类型时还会借助JAF</li>
<li>将favorParameter属性设置为true，并且请求中包含名为format参数，那么format参数的值将会mediatype属性来进行匹配，即使URL文件中没有文件扩展名也能匹配其中的媒体类型</li>
<li>ignoreAcceptHeader属性设置为true，将会忽略Accept头信息</li>
</ul>
</li>
<li>查找视图<ul>
<li>ContextNegotiatingViewResolver循环所有保存的媒体类型，找到能与之匹配内容类型的视图，完成视图解析匹配</li>
<li>如果ContextNegotiatingViewResolver没有找到合适的视图，那么它将返回null视图，或者如果useNotAcceptableStatusCode属性被设置为true，那么将返回带有http状态码406(Not Acceptable)的视图</li>
</ul>
</li>
</ol>

	
	</div>
  <a type="button" href="/archives/4a1b8e6e.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-07-29 </div>
			<div class="article-title"><a href="/archives/ac0ee78d.html" title="内置对象(又叫隐含对象，有9个内置对象)不需要预先声明就可以在脚本代码和表达式中随意使用">JSP九大内置对象、四个作用域以及六大基本动作</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><ol>
<li>request：javax.servlet.ServletRequest的子类型，此对象封装了由WEB浏览器或其它客户端生成地HTTP请求的细节（参数，属性，头标和数据）<ul>
<li>常用方法：getParameter、getParameterNames 和getParameterValues 通过调用这几个方法来获取请求对象中所包含的参数的值</li>
</ul>
</li>
<li>response： javax.servlet.ServletResponse的子类型，此对象封装了返回到HTTP客户端的输出，向页面作者提供设置响应头标和状态码的方式。经常用来设置HTTP标题，添加cookie，设置响应内容的类型和状态，发送HTTP重定向和编码URL</li>
<li>out: javax.servlet.jsp.JspWriter类型，代表输出流的对象<ul>
<li>常用的方法除了pirnt和println之外，还包括clear、clearBuffer、flush、getBufferSize和getRemaining，这是因为“out” 对象内部包含了一个缓冲区，所以需要一些对缓冲区进行操作的方法</li>
</ul>
</li>
<li>session: javax.servlet.http.HttpSession类型，主要用于跟踪对话;HttpSession是一个类似哈希表的与单一WEB浏览器会话相关的对象，它存在于HTTP请求之间，可以存储任<br>何类型的命名对象;<ul>
<li>“session” 对象建立在cookie的基础上，所以使用时应注意判断一下客户端是否打开了cookie。常用的方法包括getId、 getValue、 getValueNames和putValue等</li>
</ul>
</li>
<li>pageContext: javax.servlet.jsp.PageContext（抽象类）类型;此对象提供所有四个作用域层次的属性查询和修改能力，它也提供了转发请求到其它资源和包含其他资源的方法 ,该对象的方法都是抽象方法，代表的是当前页面运行的一些属性<ul>
<li>常用方法：findAttribute、getAttribute、getAttributesScope 和getAttributeNamesInScope</li>
<li>一般情况下pageContext对象用到得也不是很多，只有在项目所面临的情况比较复杂的情况下，才会利用到页面属性来辅助处理。</li>
</ul>
</li>
<li>application：javax.servlet.ServletContext类型，servlet的环境通过调用getServletConfig().getContext()方法获得;它提供了关于服务器版本，应用级初始化参数和应用内资源绝对路径，注册信息的方式得并设置会话属性<ul>
<li>常用的方法有getMimeType和getRealPath等</li>
</ul>
</li>
<li>config：javax.servlet.ServletConfig类型，（页面执行期）<ul>
<li>常用的方法有getInitParameter和getInitParameterNames，以获得Servlet初始化时的参数</li>
</ul>
</li>
<li>exception: java.lang.Throwable,通过JSP错误页面中一个catch块已经益出但没有捕获的java.lang.Throwable的任意实例，传向了errorPage的URI。作用域为page（页面执行期）。注意exception只有在page指令中具有属性isErrorPage=”true”时才有效。</li>
<li>page:java.lang.Object类型，指向页面自身的方式</li>
</ol>
<h2 id="内置对象与作用域对应关系"><a href="#内置对象与作用域对应关系" class="headerlink" title="内置对象与作用域对应关系"></a>内置对象与作用域对应关系</h2><table>
<thead>
<tr>
<th>对象</th>
<th>对象名称</th>
<th>所属类</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>请求对象</td>
<td>javax.servlet.ServletRequest</td>
<td>Request</td>
</tr>
<tr>
<td>response</td>
<td>相应对象</td>
<td>javax.servlet.SrvletResponse</td>
<td>Page</td>
</tr>
<tr>
<td>pageContext</td>
<td>页面上下文</td>
<td>javax.servlet.jsp.PageContext</td>
<td>Page</td>
</tr>
<tr>
<td>session</td>
<td>会话对象</td>
<td>javax.servlet.http.HttpSession</td>
<td>Session</td>
</tr>
<tr>
<td>application</td>
<td>应用程序对象</td>
<td>javax.servlet.ServletContext</td>
<td>Application</td>
</tr>
<tr>
<td>out</td>
<td>输出对象</td>
<td>javax.servlet.jsp.JspWriter</td>
<td>Page</td>
</tr>
<tr>
<td>config</td>
<td>配置对象</td>
<td>javax.servlet.ServletConfig</td>
<td>Page</td>
</tr>
<tr>
<td>page</td>
<td>页面对象</td>
<td>javax.lang.Object</td>
<td>Page</td>
</tr>
<tr>
<td>exception</td>
<td>例外对象</td>
<td>javax.lang.Throwable</td>
<td>page</td>
</tr>
</tbody>
</table>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><table>
<thead>
<tr>
<th>作用域</th>
<th>有效范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>pageContext</td>
<td>有效范围只是在当前jsp页面</td>
</tr>
<tr>
<td>request</td>
<td>有效范围只是在当前请求周期</td>
</tr>
<tr>
<td>session</td>
<td>当前会话(用户打开浏览器到用户关闭浏览器之间的过程),也就是说，只要用户不关浏览器，服务器就有办法知道这些请求是一个人发起的,整个过程被称为一个会话,而放到会话中的变量，就可以在当前会话的所有请求里使用</td>
</tr>
<tr>
<td>application</td>
<td>整个应用(只要服务器不重启，都有效);与上述三个不同的是，application里的变量可以被所有用户共用</td>
</tr>
</tbody>
</table>
<h2 id="六种基本动作"><a href="#六种基本动作" class="headerlink" title="六种基本动作"></a>六种基本动作</h2><ul>
<li><code>&lt;jsp:include page=&quot;&quot; /&gt;</code>: 在页面请求中包含一个文件</li>
<li><code>&lt;jsp:useBean id=&quot;&quot; class=&quot;&quot; scope=&quot;application page request session&quot; /&gt;</code>:寻找或者实例化一个javaBean</li>
<li><code>&lt;jsp:setProperty name=&quot;&quot; property=&quot;&quot; value=&quot;&quot; /&gt;</code>:设置javaBean的属性，通过反射调用方法</li>
<li><code>&lt;jsp:getProperty name=&quot;&quot; property=&quot;&quot;/&gt;</code>:取得某个javaBean的属性</li>
<li><code>&lt;jsp:forward page=&quot;&quot;/&gt;</code>:把请求转到一个新的页面</li>
<li><code>&lt;jsp:plugin&gt;</code>:插入Applet程序的代码</li>
<li><code>&lt;jsp:param name=&quot;&quot; value=&quot;&quot; /&gt;</code>:用于传参数，和forward一起使用</li>
</ul>

	
	</div>
  <a type="button" href="/archives/ac0ee78d.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-07-28 </div>
			<div class="article-title"><a href="/archives/3fb7ed9.html" title="MyBatis是目前非常流行的ORM框架,它的功能很强大,然而其实现却比较简单优雅;MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架;MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索;MyBatis 使用简单的 XML或注解用于配置和原始映射,将接口和 Java 的POJOs(Plain Old Java Objects:普通的 Java对象)映射成数据库中的记录">Mybatis 实现原理与结构解析</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h3 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h3><ul>
<li>Mybatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架</li>
<li>消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索</li>
<li>Mybatis使用简单的XML或注解用于配置和原始映射，将接口和Java的POJOs映射成数据库中的记录</li>
<li>每个Mybatis应用程序都是基于SqlSessionFactory实例，而一个SqlSessionFactory实例可以通过SqlSessionFactoryBuilder读取xml配置文件或者一个预定义的配置类的实例获得</li>
</ul>
<h3 id="Mybatis工作流程"><a href="#Mybatis工作流程" class="headerlink" title="Mybatis工作流程"></a>Mybatis工作流程</h3><ol>
<li>加载配置并初始化</li>
</ol>
<ul>
<li>将SQL的配置信息加载成一个个<code>MappedStatement</code>对象(包括传入参数映射配置、执行SQL语句、结果映射配置)，存储在内存中</li>
</ul>
<ol start="2">
<li>接受调用请求</li>
</ol>
<ul>
<li>触发条件：调用Mybatis提供的API</li>
<li>传入参数：为SQL的ID和传入参数对象</li>
<li>处理过程：将请求传递给下层的请求处理层进行处理</li>
</ul>
<ol start="3">
<li>处理触发请求<ul>
<li>触发条件：API接口层传递请求过来</li>
<li>传入参数：SQL的ID和传入参数的对象</li>
<li>处理过程：<pre><code>1. 根据SQL的ID查找对应的MappedStatement对象
2. 根据传入的参数对象解析MappedStatement对象，最终得到要执行的SQL和执行传入参数
3. 获取数据库连接，根据得到的最终SQL语句和执行传入参数到数据库执行，并得到执行结果
4. 根据MappedStatement对象中的结果映射配置对得到的执行结果进行转换处理，并得到最终的处理结果
5. 释放连接资源
</code></pre></li>
</ul>
</li>
<li>返回接受最终处理结果</li>
</ol>
<h3 id="工作原理结构"><a href="#工作原理结构" class="headerlink" title="工作原理结构"></a>工作原理结构</h3><ul>
<li>功能架构：Mybatis的功能架构分为四层<ol>
<li>API接口层：提供给外部使用的API接口，开发人员通过这些本地的API来操纵数据库.接口层已收到调用请求就会调用数据处理层来完成具体的数据处理</li>
<li>数据处理层：负责具体的SQL查找，SQL解析，和结果执行映射处理等，其主要目的是根据调用的请求完成一次数据库的操作</li>
<li>基础支撑层：负责最基础的功能支撑，包括连接管理，事务管理，配置加载和缓存处理，这些都是共用的，将他们抽取出来作为最基础的封装组件，为上层的数据处理提供最基础的支撑</li>
<li>引导层：配置和启动Mybatis配置信息的方式，Mybatis提供两种方式来引导Mybatis：</li>
</ol>
<ul>
<li>基于XML配置文件获取配置信息</li>
<li>基于Java API的方式<center><br><img src="http://qvm.lays3721.top/%E5%8A%9F%E8%83%BD%E6%9E%B6%E6%9E%84.png" alt="Mybatis功能架构"><br></center></li>
</ul>
</li>
<li>框架架构：<ol>
<li>加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载为宜个MappedStatement对象(包括传入参数映射配置，执行的SQL语句，结果映射配置)　，存储在内存中</li>
<li>SQL解析：当API接口层接收到调用请求时，会接受到传入SQL的ID和传入对象(可以是Map、JavaBean对象或者是基本数据类型)，Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数</li>
<li>SQL执行：将最终得到的SQL语句和参数传入数据库中执行，得到数据库返回的执行结果</li>
<li>结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap，JavaBean或者基本数据类型，并将最终结果返回<center><br><img src="http://qvm.lays3721.top/%E5%8A%9F%E8%83%BD%E6%9E%B6%E6%9E%84.png" alt="Mybatis框架架构"><br>Panda<br></center>
</li>
</ol>
</li>
</ul>

	
	</div>
  <a type="button" href="/archives/3fb7ed9.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-07-28 </div>
			<div class="article-title"><a href="/archives/4b2bec15.html" title="迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构;迭代器通常被称为“轻量级”对象，因为创建它的代价小.">Java 迭代器Iterator的用法</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h3 id="迭代器-Iterator-概述"><a href="#迭代器-Iterator-概述" class="headerlink" title="迭代器(Iterator)概述"></a>迭代器(Iterator)概述</h3><ul>
<li>Iterator是作为一个接口存在的，它定义了迭代器所具有的功能</li>
<li>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构;迭代器通常被称为“轻量级”对象，因为创建它的代价小.</li>
</ul>
<h3 id="迭代器的好处"><a href="#迭代器的好处" class="headerlink" title="迭代器的好处"></a>迭代器的好处</h3><ol>
<li>迭代器可以提供统一的迭代方式。</li>
<li>迭代器也可以在对客户端透明的情况下，提供各种不同的迭代方式。</li>
<li>迭代器提供一种<a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtyfour.html" target="_blank" rel="noopener">快速失败机制</a>，防止多线程下迭代的不安全操作。</li>
</ol>
<h3 id="功能方法"><a href="#功能方法" class="headerlink" title="功能方法"></a>功能方法</h3><ul>
<li><p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line">		while(iter.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line">			iter.next();</span><br><span class="line">			//System.out.println(iter.next());</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java中的迭代器功能比较简单，并且只能单向移动;</p>
</li>
<li>方法:<code>iterator();</code>要求容器返回一个Iterator;第一次调用Iterator的next()方法时，它返回序列的第一个元素</li>
<li><code>next();</code>获得序列中的下一个元素</li>
<li><code>hasNext();</code>检查序列中是否还有元素</li>
<li><code>remove();</code>将迭代器新返回的元素删除</li>
</ul>
<h3 id="知识扩充-遍历List集合的方法"><a href="#知识扩充-遍历List集合的方法" class="headerlink" title="知识扩充(遍历List集合的方法)"></a>知识扩充(遍历List集合的方法)</h3><ul>
<li><p>foreache 遍历：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(String tmp:list)&#123;</span><br><span class="line">			System.out.println(tmp);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 循环遍历：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; list.size(); i++)&#123;</span><br><span class="line">			list.get(i);</span><br><span class="line">			System.out.println(list.get(i));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Iterator遍历(例子上面已经给出)</p>
</li>
<li><p>其中，对于同一个List集合，统计每个遍历方式时间消耗如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List first visit method(foreache):</span><br><span class="line">Run Time:170(ms)</span><br><span class="line">List second visit method(for):</span><br><span class="line">Run Time:10(ms)</span><br><span class="line">List Third visit method(Iterator):</span><br><span class="line">Run Time:34(ms)</span><br></pre></td></tr></table></figure>
</li>
<li><p>显而易见；迭代器遍历在时间上的优势很大，代码简洁</p>
</li>
<li>同时，与for/foreach 相比，Iterator使用相同方式去遍历集合中元素，而不用考虑集合类的内部实现(只要它实现了 java.lang.Iterable 接口)</li>
</ul>

	
	</div>
  <a type="button" href="/archives/4b2bec15.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-07-26 </div>
			<div class="article-title"><a href="/archives/69b20980.html" title="视图是存储在数据库中的查询的SQL 语句，它主要出于两种原因：安全原因， 视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。这个视图就像一个“窗口”，从中只能看到你想看的数据列">Mysql视图技术原理与应用</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h3 id="视图概述"><a href="#视图概述" class="headerlink" title="视图概述"></a>视图概述</h3><ul>
<li>定义：视图是一个虚拟表，其内容由查询定义，视图表内存在行列数据，但是不在数据库中以存储的数据值集形式存在，行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成.</li>
<li>更新过程：当查询视图时，数据库从相应的引用表中引入数据到视图表</li>
<li>视图技术优点：<ul>
<li>视图能简化用户操作：视图机制使用户可以将注意力集中在所关心的数据上，使数据库看起来结构简单，清晰，并简化用户的查询操作</li>
<li>视图使用户能以多种身份看待数据：灵活地实现多种不同类型的用户共享同一个数据库</li>
<li>视图对重构数据库提供了不同程度上的逻辑独立性：重构时(数据库逻辑改变)，新增关系表或者对原有关系增加新字段，不会影响应用程序所需的数据查询形式</li>
<li>适当的利用视图可以更清晰地表达查询</li>
</ul>
</li>
</ul>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例:"></a>使用案例:</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><ul>
<li><code>ALGORITHM</code>:定义查询算法<ul>
<li><code>MERGE</code>:将查询视图的语句与视图的定义语句合并处理</li>
<li><code>TEMPTABLE</code>:视图查询的结果保存到临时表，而后在该临时表基础上执行查询视图的语句</li>
<li><code>UNDEFINED</code> : 由Mysql选择使用的算法，一般首选MERGE，因为MERGE更有效率，而且TEMPTABLE不支持更新</li>
</ul>
</li>
<li>WITH[CASCADED|LOCAL] CHECK OPTION 解析<ul>
<li>LOCAL参数表示更新视图时只要满足该视图本身定义的条件即可</li>
<li>CASCADED参数表示更新视图时需要满足所有相关视图和表的条件;没有指明时，该参数为默认值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW [db_name.]view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="创建视图："><a href="#创建视图：" class="headerlink" title="创建视图："></a>创建视图：</h4><ul>
<li>在单表上创建：<code>create view vName(id,sex,age) as select id,sex,age from student;</code></li>
<li>在多表上创建：<code>CREATE VIEW VName(ID, NAME, SEX, AGE,DEPARTMENT,POS,EXPERENCE) AS SELECT a.ID, a.NAME, a.SEX, a.AGE,a.DEPARTMENT,b.POS,b.EXPERENCE FROM learning.t_employee a,learning.t_employee_detail b WHERE a.ID=b.ID;</code></li>
<li>查看视图：<code>DESCRIBE vName;</code>或<code>SHOW TABLE STATUS;</code>或<code>SHOW CREATE VIEW VnAME;</code></li>
<li>修改视图：<ul>
<li><code>create or replace</code> 指令：<code>CREATE OR REPLACE VIEW V_VIEW1(ID, NAME, SEX) AS SELECT ID, NAME, SEX  FROM learning.t_employee;</code></li>
<li><code>ALERT</code>指令: <code>ALTER VIEW  V_VIEW1(ID, NAME) AS SELECT ID, NAME  FROM learning.t_employee;</code></li>
</ul>
</li>
<li>更新视图：主要通过(insert,update,delete)操作表中数据；由于视图上的数据来自于基本表，更新视图虚拟表上的数据都会转换到基本表更新.<ul>
<li>更新视图时，只能更新权限范围内的数据，超出范围，不能更新</li>
<li>指令实例：<code>update vName set project=&quot;psychonologic&quot; where id = 2;</code></li>
<li>不可更新的视图：由于虚拟表对应实体表中的数据，所以不是所有的视图表都能更新；如果视图含有下列结构中的任何一种，则不能更新：<ul>
<li>聚合函数(SUM(),MIN(),MAX(),COUNT()…)</li>
<li>DISTINCT</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION/UNION ALL</li>
<li>位于选择序列中的子查询</li>
<li>Jion</li>
<li>FROM字句中的不可更新视图</li>
<li>WHERE子句的子查询，引用FROM字句的表</li>
<li>仅引用文字值</li>
<li>ALGORITHM = TEMPTABLE</li>
</ul>
</li>
<li>对于更新操作的提醒：视图虽然可以更新数据，但是有很多限制，一般情况下，最好将视图作为查询数据的虚拟表，而不要通过视图更新数据. 对于一些结构更加复杂的数据库表，最好在实体表中更新数据</li>
</ul>
</li>
</ul>

	
	</div>
  <a type="button" href="/archives/69b20980.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-07-25 </div>
			<div class="article-title"><a href="/archives/64423a64.html" title="触发器可以用于记录对数据库的操作，它是一种与表操作有关的数据库对象，当触发器所在表上出现某个触发事件以及触发事件时，将调用该对象。即表的操作事件触发表上的触发器的执行">mysql触发器学与用</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h3 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h3><ul>
<li>Mysql在5.0.2版本以上开始支持触发器，触发器是有某些带有命令的的时间来出发某些操作，这些事件操作包括 insert delete update…</li>
<li>触发器可以用于记录对数据库的操作，它是一种与表操作有关的数据库对象，当触发器所在表上出现某个触发事件以及触发事件时，将调用该对象。即表的操作事件触发表上的触发器的执行</li>
</ul>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><ul>
<li><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CRATE TRIGGER TRIGGER_NAME </span><br><span class="line">TRIGGER_TIME</span><br><span class="line">TRIGGER_EVENT ON TRIGGER_TABLE</span><br><span class="line">FOR EACH ROW</span><br><span class="line">TRIGGER_STATEMEMTS</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析：</p>
<ul>
<li>TRIGGER_NAME : 表示触发器名称，用户自定义</li>
<li>TRIGGER_TIME :  标识触发时机，取值为：before 、 after </li>
<li>TRIGGER_EVENT : 标识触发事件，取值为：INSERT , UPDATE ,DELETE</li>
<li>TRIGGER_TABLE ：标识建立触发器的表名，也就是触发器的表对象</li>
<li>TRIGGER_STATEMENT：触发器程序体，可以是一条语句，或如果是多条语句，用<code>begin [stmt_list] end;</code>包含，但是每条语句之间用分好分隔</li>
<li>根据触发时机与触发事件的组合，可以看出，最多可以建立6种触发器(注：一个表上不能简历相同的触发器)</li>
</ul>
</li>
<li>对于<code>begin...end</code>，由于中间使用了分号(mysql中标记执行完语句的符号)而导致begin找不到与之匹配的end，因此引入了<code>DELIMITER</code>命令，作为定界分隔符；<code>end$ DELIMITER ;</code></li>
</ul>
<h3 id="一个完整的触发器示例"><a href="#一个完整的触发器示例" class="headerlink" title="一个完整的触发器示例"></a>一个完整的触发器示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">create trigger tri_stuInsert after insert</span><br><span class="line">on student for each row</span><br><span class="line">begin</span><br><span class="line">declare c int;</span><br><span class="line">set c = (select stuCount from class where classID=new.classID);</span><br><span class="line">update class set stuCount = c + 1 where classID = new.classID;</span><br><span class="line">end $</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>mysql用使用DECLARE 来定义局部变量，并且该遍历只能在BEGIN…END之间使用，并且只能放在期间复合语句的开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：DECLARE var_name[,...] type [DEFAULT value]</span><br></pre></td></tr></table></figure>
</li>
<li><p>new与old：</p>
<ul>
<li>INSERT型触发器 ：NEW表示将要(BEFORE)或已经(AFTER)插入的新数据</li>
<li>UPDATE型触发器：OLD用来表示将要或者已经被修改的原数据，NEW表示将要或者已经被修改的新数据</li>
<li>DELETE型触发器：OLD用来表示将要或已经被删除的数据</li>
<li>并且，OLD是只读的，而NEW可以在触发器中使用set赋值，避免二次触发触发器，造成循环调用</li>
</ul>
</li>
</ul>
<h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3><ul>
<li>语法：可以在后面指定数据库名来查看触发器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show triggers [from scheme_name];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><ul>
<li>语法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop trigger [if exists] trigger_name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="触发器执行顺序"><a href="#触发器执行顺序" class="headerlink" title="触发器执行顺序"></a>触发器执行顺序</h3><ul>
<li>我们建立的数据库一般都是 InnoDB 数据库，其上建立的表是事务性表，也就是事务安全的。这时，若SQL语句或触发器执行失败，MySQL 会回滚事务，有：</li>
</ul>
<ol>
<li>如果 BEFORE 触发器执行失败，SQL 无法正确执行</li>
<li>SQL 执行失败时，AFTER 型触发器不会触发</li>
<li>AFTER 类型的触发器执行失败，SQL 会回滚</li>
</ol>

	
	</div>
  <a type="button" href="/archives/64423a64.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/4/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> 上一页</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/6/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			<div class="widget">
    
</div>

		
			
		
			
	<div class="widget">
		<h4>标签云</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/Redis/">Redis<span>4</span></a></li>
		
			<li><a href="/tags/Hibernate/">Hibernate<span>2</span></a></li>
		
			<li><a href="/tags/JVM/">JVM<span>1</span></a></li>
		
			<li><a href="/tags/Linux/">Linux<span>2</span></a></li>
		
			<li><a href="/tags/V2ray/">V2ray<span>1</span></a></li>
		
			<li><a href="/tags/RabbitMQ/">RabbitMQ<span>1</span></a></li>
		
			<li><a href="/tags/Mysql/">Mysql<span>9</span></a></li>
		
			<li><a href="/tags/Git/">Git<span>2</span></a></li>
		
			<li><a href="/tags/Web/">Web<span>3</span></a></li>
		
			<li><a href="/tags/Servlet/">Servlet<span>2</span></a></li>
		
			<li><a href="/tags/leetcode/">leetcode<span>1</span></a></li>
		
			<li><a href="/tags/Maven/">Maven<span>1</span></a></li>
		
			<li><a href="/tags/动态代理/">动态代理<span>4</span></a></li>
		
			<li><a href="/tags/struts2/">struts2<span>1</span></a></li>
		
			<li><a href="/tags/Spring/">Spring<span>5</span></a></li>
		
			<li><a href="/tags/Angular-JS/">Angular JS<span>2</span></a></li>
		
			<li><a href="/tags/NetWorker/">NetWorker<span>2</span></a></li>
		
			<li><a href="/tags/场景/">场景<span>1</span></a></li>
		
			<li><a href="/tags/多线程/">多线程<span>4</span></a></li>
		
			<li><a href="/tags/Java/">Java<span>32</span></a></li>
		
		
		   <li><a href="/tags">...<span>24</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/archives/27e17559.html"  title="redis总的所有数据默认保存在内存当中的.但场景需要，有时候需要进行持久化保存" ><i class="fa fa-file-o"></i>Redis持久化方案</a>
      </li>
    
      <li>
        <a href="/archives/3eac123.html"  title="当一个系统访问量上来的时候，不只是数据库性能瓶颈问题了，数据库数据安全也会浮现，这时候合理使用数据库锁机制就显得异常重要了。" ><i class="fa fa-file-o"></i>数据库锁机制分类</a>
      </li>
    
      <li>
        <a href="/archives/7ffea1fe.html"  title="RabbitMQ消息作为分布式消息协同工具，承担者协同各个系统之间的正常通信。如何确保消息通过RabbitMQ传输而不丢失数据？" ><i class="fa fa-file-o"></i>RabbitMQ消息可靠性</a>
      </li>
    
      <li>
        <a href="/archives/28d7adef.html"  title="快速失败：当在迭代一个集合的时候，如果有另外一个线程在修改这个集合，就会抛出ConcurrentModification异常，java.util下都是快速失败。 安全失败：在迭代时候会在集合二层做一个拷贝，所以在修改集合上层元素不会影响下层。在java.util.concurrent下都是安全失败" ><i class="fa fa-file-o"></i>快速失败与安全失败机制</a>
      </li>
    
      <li>
        <a href="/archives/a1cd7aa8.html"  title="从Integer缓存池的角度看Integer比较大小" ><i class="fa fa-file-o"></i>Integer封装类比较大小</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/RicoNut" title="My Github account." target="_blank"]);">RicoNut Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


    </div>
  </div>
  <div class="container-narrow">
    <footer> <p>
  &copy; 2019 Rico Nut
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
</html>