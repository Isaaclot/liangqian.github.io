<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>哈姆雷特1001</title>
  <meta name="author" content="Rico Nut">
  
  <meta name="description" content="学习总结 思考感悟 知识管理">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="哈姆雷特1001"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/cerulean.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  



</head>

<body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">哈姆雷特1001</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
    <div class="content">
      <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">哈姆雷特1001</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      Stay Hungry.
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-12-20 </div>
			<div class="article-title"><a href="/archives/27e17559.html" title="redis总的所有数据默认保存在内存当中的.但场景需要，有时候需要进行持久化保存">Redis持久化方案</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="持久化方案有2种"><a href="#持久化方案有2种" class="headerlink" title="持久化方案有2种:"></a>持久化方案有2种:</h4><h5 id="Rdb-快照形式"><a href="#Rdb-快照形式" class="headerlink" title="Rdb: 快照形式"></a><code>Rdb</code>: 快照形式</h5><ul>
<li>定期把内存中当前时刻的数据保存在硬盘中，是Redis默认支持的持久化方案</li>
<li><code>Rdb</code>是一个半持久化模式，即按照一定的策略周期将数据保存在磁盘中，其中保存数据的文件为<code>dump.rdb</code></li>
<li>在Redis服务重启的时候，会执行一遍备份文件中的数据</li>
<li><p><code>Rdb</code>配置文件的默认配置方式如下(可见redis.conf)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1    #当有一条Keys数据被改变时，900秒刷新到Disk一次</span><br><span class="line">save 300 10   #当有10条Keys数据被改变时，300秒刷新到Disk一次</span><br><span class="line">save 60 10000 #当有10000条Keys数据被改变时，60秒刷新到Disk一次</span><br></pre></td></tr></table></figure>
</li>
<li><p>snapshot快照持久化Redis的文件持久化方式，决定了其在持久化的时候，有可能会出现数据丢失的情况，如果Redis服务器发生故障，那么故障前保存在内存中的数据可能没有命中持久化周期，可能会丢失。</p>
</li>
<li>同时Redis的RDB文件，也是主从复制内部实现的重要一环<ol>
<li>第一次Slave向master同步的实现：Salve向master发出请求同步的时候，master将数据dump到RDB文件中，然后将RDB文件全量传输给Slave，然后发送执行快照恢复的命令给Slave，实现初次同步</li>
<li>第二次以后的同步：master将变量的快照直接实时同步给Slave</li>
<li>只要master和Slave法师断开和重连，肯定会发生以上两个同步工序，Redis主从复制是建立在内存快照的持久化基础上的，只要有Slave就一定会有内存快照发生。</li>
</ol>
</li>
</ul>
<h5 id="AOF形式"><a href="#AOF形式" class="headerlink" title="AOF形式"></a><code>AOF</code>形式</h5><ul>
<li><code>AOF</code>持久化时，Redis会将每一个收到的写命令都通过<code>write</code>函数追加到文件中，类似mysql的binlog，当服务器重启当时候，会执行该持久化文件进行数据恢复</li>
<li><p>对应的参数配置如下(redis.conf)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes       #启用AOF持久化方式</span><br><span class="line">appendfilename appendonly.aof #AOF文件的名称，默认为appendonly.aof</span><br><span class="line"># appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。</span><br><span class="line">appendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。</span><br><span class="line"># appendfsync no     #完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>AOF</code>持久化类似于日志记录形式，每条数据的改变记录都会记录在AOF文件中，随着数据操作次数变多，AOF文件越来越臃肿，但是对于一个键值的操作，在进行数据恢复的时候，只有一条数据记录是有效的<br>为了压缩AOF文件，Redis提供bgrewriteaof命令，收到此命令的时，Redis使用与快照的方式，将内存中数据以命令的方式保存在临时文件中，最后替换原来的文件，以此控制AOF文件的增长</p>
</li>
<li><code>bgrewriteaof</code>使用配置如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">no-appendfsync-on-rewrite yes   #在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，避免与命令的追加造成DISK IO上的冲突。</span><br><span class="line">auto-aof-rewrite-percentage 100 #当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。</span><br><span class="line">auto-aof-rewrite-min-size 64mb  #当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="持久化方案的选择"><a href="#持久化方案的选择" class="headerlink" title="持久化方案的选择"></a>持久化方案的选择</h4><ul>
<li>如果能接受数据灾难带来的前几分钟的数据丢失，推荐使用RDB持久化形式</li>
<li>如果考虑到完全使用AOF持久化会带来性能方面的问题，比如持久化带来阻塞等，可以使用RDB和AOF配合使用，RDB可以定期保存一份完整的快照，而AOF能保证减少数据丢失，提高数据保障性</li>
</ul>

	
	</div>
  <a type="button" href="/archives/27e17559.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-12-01 </div>
			<div class="article-title"><a href="/archives/3eac123.html" title="当一个系统访问量上来的时候，不只是数据库性能瓶颈问题了，数据库数据安全也会浮现，这时候合理使用数据库锁机制就显得异常重要了。">数据库锁机制分类</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h5 id="按照封锁类型分类"><a href="#按照封锁类型分类" class="headerlink" title="按照封锁类型分类"></a>按照封锁类型分类</h5><ul>
<li>排他锁(<code>X锁</code>)：又称为写锁；如果当前事务获得X锁，会阻塞其他事务的读与写，当前事务释放当前对象的X锁之前，其他事务不能对当前对象进行读或者写；</li>
<li>共享锁(<code>S锁</code>)：又称为读锁；如果当前事务获得了S锁，其他事务只能再对当前对象加S锁，而不能加X锁，保证其他事务可以读当前对象，不可用对当前对象作出更改</li>
</ul>
<h5 id="按照锁的封锁类型分类"><a href="#按照锁的封锁类型分类" class="headerlink" title="按照锁的封锁类型分类"></a>按照锁的封锁类型分类</h5><ul>
<li>行级锁(<code>MySql InnoDb</code>支持)<ol>
<li>优点：锁定粒度小(最小), 发生锁冲突的几率最低，并发度也最高；</li>
<li>缺点：获取锁与释放锁需要的开销比较大；会出现死锁；如果大部分数据操作涉及到<code>order by</code>或者全表扫描的情景，效率明显比其他锁要慢</li>
</ol>
</li>
<li>表级锁<ol>
<li>优点：开销小，加锁与释放锁效率高</li>
<li>缺点：锁定粒度大，发生锁冲突的概率高，并发度低。</li>
</ol>
</li>
<li>页级锁(<code>MySql</code>特有)<ol>
<li>优点：锁定粒度处于两个极端(行级锁与表级锁)之间；所以并发处理能力也处于上面两者之间</li>
<li>缺点：页级锁定和行级锁定一样，会发生死锁</li>
</ol>
</li>
<li>什么时候使用表级锁？<ul>
<li>对于InnoDB，大多数情况下都是选择使用行级锁；因为行级锁和事务支持是我们选择使用InnoDB的理由；</li>
<li>但是，也存在特殊情况：<ol>
<li>事务需要更新大部分或者全部数据，表又比较大，如果使用默认的行锁，处理每条数据都需要进行加锁和释放锁的操作，导致开销非常大，事务执行效率底下；也可能导致其他事务长时间等待或锁冲突；这种情况适合采用锁表来提高事务的执行效率；</li>
<li>事务操作设计到的表比较多，并且复杂，容易引起死锁，或者可能造成大量事务回滚。这样情况也可以考虑使用表锁进行数据库性能上的优化；</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="按照锁的使用方式划分"><a href="#按照锁的使用方式划分" class="headerlink" title="按照锁的使用方式划分"></a>按照锁的使用方式划分</h5><ul>
<li>悲观锁<ol>
<li>悲观并发锁(<code>PCC</code>)：总是假设最坏的情况，每次去操作数据的时候，都认为别人会进行修改，所以每次操作数据的时候都会上锁，这样别人想操作这个数据的时候，就会阻塞，知道锁被释放；共享资源每次只给一个线程\事务使用，其他线程阻塞，锁被释放才会转让操作权</li>
<li>使用场景：适用于多写情景下；避免数据冲突导致的数据不一致的问题</li>
</ol>
</li>
<li>乐观锁<ol>
<li>乐观并发锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，不会加锁； 但是再更新到时候，都会判断一下在此期间别人有木有更新这个数据，这个检查的实现可以是通过版本号机制和CAS算法实现</li>
<li>使用场景：适用于多读情景下；数据冲突发生少，可以省去锁开销</li>
</ol>
</li>
</ul>

	
	</div>
  <a type="button" href="/archives/3eac123.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-11-26 </div>
			<div class="article-title"><a href="/archives/7ffea1fe.html" title="RabbitMQ消息作为分布式消息协同工具，承担者协同各个系统之间的正常通信。如何确保消息通过RabbitMQ传输而不丢失数据？">RabbitMQ消息可靠性</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="RabbitMQ服务器数据不丢失"><a href="#RabbitMQ服务器数据不丢失" class="headerlink" title="RabbitMQ服务器数据不丢失"></a>RabbitMQ服务器数据不丢失</h4><ul>
<li>在<code>RabbitMQ</code>服务器中，我们通过持久化数据，来保证服务器故障或重启之后，能够恢复数据来防治数据丢失</li>
<li>在定义<code>channel</code>的时候, 设置该通道的消息持久化。<h4 id="消息生产者传输到服务器不丢包"><a href="#消息生产者传输到服务器不丢包" class="headerlink" title="消息生产者传输到服务器不丢包"></a>消息生产者传输到服务器不丢包</h4></li>
<li>事务控制： 使用AMQP的自带的事务管理模式确保消息已经发送到RabbitMQ服务器，但是会带来更大的吞吐量，大量消息发送</li>
<li>使用Confirm模式确认(异步)<ol>
<li>将生产者<code>Channel</code>设置为<code>Confirm</code>模式，一旦<code>channel</code>进入<code>confirm</code>模式之后，所有在该信道上面发布的消息都会指派一个唯一的Id，一旦消息被投递到所匹配的队列之后，Broker就会发送一个确认给生产者，这样生产者就知道了消息已经到达目的地。</li>
</ol>
</li>
</ul>
<h4 id="确认消费者已经正常处理消息"><a href="#确认消费者已经正常处理消息" class="headerlink" title="确认消费者已经正常处理消息"></a>确认消费者已经正常处理消息</h4><ul>
<li>为了保证消息正常的到达消费者，RabbitMQ提供了消息的<code>acknowledgement</code>来确认消息</li>
<li>默认的消息确认设置是自动确认，且服务端不记录确认结果(<code>autoAck=None; isAutoAck=false</code>)；<code>autoAck=None;</code>表示消息发送现实的回复确认之后，消息才从服务器中移除，但是<code>acknowledgement</code>设置了Auto的话，那么<code>isAutoAck=true</code>就不安全了。消息发送出去之后，可能还没到达消费者，TCP链接就断开，因为配置了auto，消息发出之后，就移除消息，默认消费者已经正常处理。</li>
<li>还可以设置<code>autoAck=Normal; isAutoAck=false</code>，那么每次的消息确认操作，就需要消费者手动确认(<code>basc.ack,basic.nack等</code>),消息从服务器队列中移除或者重新入队。</li>
</ul>

	
	</div>
  <a type="button" href="/archives/7ffea1fe.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-11-13 </div>
			<div class="article-title"><a href="/archives/28d7adef.html" title="快速失败：当在迭代一个集合的时候，如果有另外一个线程在修改这个集合，就会抛出ConcurrentModification异常，java.util下都是快速失败。 安全失败：在迭代时候会在集合二层做一个拷贝，所以在修改集合上层元素不会影响下层。在java.util.concurrent下都是安全失败">快速失败与安全失败机制</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="快速失败机制-fail-fast"><a href="#快速失败机制-fail-fast" class="headerlink" title="快速失败机制(fail-fast)"></a>快速失败机制(<code>fail-fast</code>)</h4><ul>
<li>在迭代器迭代的时候对集合进行修改：</li>
</ul>
<p><code>案例代码：</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;UML&quot;);</span><br><span class="line">list.add(&quot;PDF&quot;);</span><br><span class="line">list.add(&quot;VRP&quot;);</span><br><span class="line">// 1. 使用iterator遍历的时候发生更改，会导致 ConcurrentModificationException</span><br><span class="line">//        Iterator iterator = list.iterator();</span><br><span class="line">//        while (iterator.hasNext()) &#123;</span><br><span class="line">//            list.remove(1);</span><br><span class="line">//        &#125;</span><br><span class="line">//2. 使用foreach遍历的时候发生更改，会导致 ConcurrentModificationException</span><br><span class="line">//        for (String str : list)&#123;</span><br><span class="line">//            list.remove(1);</span><br><span class="line">//        &#125;</span><br><span class="line">//3. 使用for i 的形式遍历的时候发生更改，不会导致 ConcurrentModificationException。</span><br><span class="line">//        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">//            list.remove(1);</span><br><span class="line">//        &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>执行的异常结果：</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br><span class="line">	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span><br><span class="line">	at java.util.ArrayList$Itr.next(ArrayList.java:859)</span><br></pre></td></tr></table></figure></p>
<p><code>结果分析：</code>当迭代器遍历一个集合对象的时候，对集合对象进行内容修改(包括：赠删改)，则会抛出异常：<code>ConcurrentModificationException</code></p>
<ul>
<li>《Java编程思想》对快速失败(快速报错)的解释<ol>
<li>Java容器有一种保护机制，能够防止多个进程同时修改一个容器的内容。如果你正在迭代遍历某个容器的过程中，另一个线程对介入，并插入、删除、或修改容器中的某个对象，那么就会出现问题：也许迭代过程中已经处理了该对象，也许没有处理，也需要在调用<code>size()</code>方法之后容器的尺寸收缩了—–还有许多的灾难情景。</li>
<li>Java容器类类库采用<code>快速报错(fail-fast)</code>机制。它会探查容器上任何除了你的线程所进行的操作以外其他的所有变化，一旦发现其他线程对容器进行修改，就会立刻抛出<code>ConcurrentModificationException</code>异常</li>
<li>引用自书籍《Java编程思想》<code>17.11.3</code>章节</li>
</ol>
</li>
<li>快速失败原理：<ul>
<li>迭代器在便利一个集合对象时，并且在遍历过程中使用一个<code>modCount</code>变量。集合在遍历期间如果内容发生变化，就会改变<code>modCount</code>的值。每当迭代器使用<code>hashNext()/next()</code>遍历下一个元素的时候，都会检测<code>modCount</code>变量是否为<code>expectedmodCount</code>的值，如果是，则返回便利；否则抛出异常，终止便利。这里异常的抛出条件是检测到 <code>modCount！=expectedmodCount</code> 这个条件。如果集合发生变化时修改<code>modCount</code>值刚好又设置为了<code>expectedmodCount</code>值.</li>
<li>场景参考：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改(指的是迭代过程中被修改)<h4 id="安全失败机制-fail-safe"><a href="#安全失败机制-fail-safe" class="headerlink" title="安全失败机制(fail-safe)"></a>安全失败机制(<code>fail-safe</code>)</h4></li>
</ul>
</li>
<li>java.util.concurrent包下list执行迭代时修改操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        //同样的代码：采用具备安全失败(fail-safe)的集合容器来创建对象</span><br><span class="line">        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;UML&quot;);</span><br><span class="line">        list.add(&quot;PDF&quot;);</span><br><span class="line">        list.add(&quot;VRP&quot;);</span><br><span class="line">        // 1. 使用iterator遍历的时候发生更改，不会导致 ConcurrentModificationException</span><br><span class="line">//        Iterator iterator = list.iterator();</span><br><span class="line">//        while (iterator.hasNext()) &#123;</span><br><span class="line">//            list.remove(1);</span><br><span class="line">//            break;</span><br><span class="line">//        &#125;</span><br><span class="line">        //2. 使用foreach遍历的时候发生更改，不会导致 ConcurrentModificationException</span><br><span class="line">//        for (String str : list)&#123;</span><br><span class="line">//            list.remove(1);</span><br><span class="line">//            break;</span><br><span class="line">//        &#125;</span><br><span class="line">        //3. 使用for i 的形式遍历的时候发生更改，不会导致 ConcurrentModificationException。</span><br><span class="line">//        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">//            list.remove(1);</span><br><span class="line">//            break;</span><br><span class="line">//        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>执行正常</code></p>
<ul>
<li>安全失败机制<ul>
<li>原理：由于迭代的时候，对原集合的拷贝进行遍历，所以在遍历过程中，对原集合所做的修改不能被迭代器检测到，所以不会触发<code>ConcurrentModificationException</code>异常</li>
<li>缺点：基于拷贝内容的容器虽然是避免来<code>ConcurrentModificationException</code>异常，但是同样地，拷贝出来的内容不能同步到原集合中内容信息的修改，可能会造成容器数据版本落后。</li>
<li>场景参考：<code>java.util.concurrent</code>包下的容器都是安全失败的，可以在多线程并发下使用，并发修改。</li>
<li>快速失败，安全失败是相对于迭代器而言的，包括iterator和foreach，不包括for i ；</li>
</ul>
</li>
</ul>

	
	</div>
  <a type="button" href="/archives/28d7adef.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-11-06 </div>
			<div class="article-title"><a href="/archives/a1cd7aa8.html" title="从Integer缓存池的角度看Integer比较大小">Integer封装类比较大小</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="先上Demo，Integer数据的比较大小"><a href="#先上Demo，Integer数据的比较大小" class="headerlink" title="先上Demo，Integer数据的比较大小"></a>先上Demo，Integer数据的比较大小</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">128</span>;</span><br><span class="line">        Integer b = <span class="number">128</span>;</span><br><span class="line">        <span class="comment">//test-1</span></span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            System.out.println(<span class="string">" a is equal to b"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Integer c = <span class="number">127</span>;</span><br><span class="line">        Integer d = <span class="number">127</span>;</span><br><span class="line">        <span class="comment">//test-2</span></span><br><span class="line">        <span class="keyword">if</span> (c == d) &#123;</span><br><span class="line">            System.out.println(<span class="string">"c is equal to d"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">128</span>;</span><br><span class="line">        <span class="comment">//test-3</span></span><br><span class="line">        <span class="keyword">if</span> (a == e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"a is equal to e"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">127</span>;</span><br><span class="line">        <span class="comment">//test-4</span></span><br><span class="line">        <span class="keyword">if</span> (f == c) &#123;</span><br><span class="line">            System.out.println(<span class="string">"f is equal to c"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Integer g = <span class="number">129</span>;</span><br><span class="line">        <span class="comment">//test-5</span></span><br><span class="line">        <span class="keyword">if</span> (g &gt; a) &#123;</span><br><span class="line">            System.out.println(<span class="string">"g is larger to a"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//test-6</span></span><br><span class="line">        <span class="keyword">if</span> (g &gt; c) &#123;</span><br><span class="line">            System.out.println(<span class="string">"g is larger to c"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 结果：</span></span><br><span class="line"><span class="comment">         *    c is equal to d</span></span><br><span class="line"><span class="comment">         *    a is equal to e</span></span><br><span class="line"><span class="comment">         *    f is equal to c</span></span><br><span class="line"><span class="comment">         *    g is lager to a</span></span><br><span class="line"><span class="comment">         *    g is larger to c</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点分析"><a href="#测试点分析" class="headerlink" title="测试点分析"></a>测试点分析</h4><ol>
<li><code>test-1</code>：Intger数值超出<code>Integer.MinValue（-128）</code>和<code>Integer.MaxValue（127）</code>的范围，用等号比较大小，数值不等</li>
<li><code>test-2</code>：Intger数值在<code>Integer.MinValue（-128）</code>和<code>Integer.MaxValue（127）</code>的范围内，用等号比较大小，数值相等</li>
<li><code>test-3</code>和：<code>test-4</code>：Integer数值在Integer范围内或者范围外与int基本数据类型进行比较；只要数值相等，两者都相等</li>
<li><code>test-5</code>和：<code>test-6</code>: Integer数值在不超出int的范围内进行比较，只比较数值的大小</li>
</ol>
<h4 id="实验结果总结"><a href="#实验结果总结" class="headerlink" title="实验结果总结"></a>实验结果总结</h4><ul>
<li>在-128~127的Integer值并且以Integer x = value;的方式赋值的Integer值在进行==和equals比较时，都会返回true；因为在此范围内的Integer的数值用的是原生数据类型int，会在内存中重用；比较的时候，只比较数值大小</li>
<li>超出-128~127的Integer的数值比较的时候，不仅比较数值的大小，还比较对象的引用地址是否一致</li>
<li>而Integer类型与int比较大小的时候，只比较数值大小；因为Integer会自动拆箱操作，转换成int类型再进行比较</li>
<li>对于超出-128~127的Integer比较数值是否相等的时候，采用<code>equal()</code>方法进行比较;但是实际生成环境中，无法确定Integer的范围时候，只能都用<code>equal()</code>进行Integer类型的大小比较;</li>
<li>jdk中<code>equal()</code>源码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compares this object to the specified object.  The result is</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> true&#125; if and only if the argument is not</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; and is an &#123;<span class="doctag">@code</span> Integer&#125; object that</span></span><br><span class="line"><span class="comment"> * contains the same &#123;<span class="doctag">@code</span> int&#125; value as this object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   obj   the object to compare with.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the objects are the same;</span></span><br><span class="line"><span class="comment"> *          &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

	
	</div>
  <a type="button" href="/archives/a1cd7aa8.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-10-26 </div>
			<div class="article-title"><a href="/archives/9b0bd708.html" title="Nginx负载均衡（工作在七层“应用层”）功能主要是通过upstream模块实现，Nginx负载均衡默认对后端服务器有健康检测的能力，仅限于端口检测，在后端服务器比较少的情况下负载均衡能力表现突出。">Nginx的负载均衡策略</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="Nginx负载均衡模块的作用"><a href="#Nginx负载均衡模块的作用" class="headerlink" title="Nginx负载均衡模块的作用"></a>Nginx负载均衡模块的作用</h4><ol>
<li>负载均衡模块用于从”upstream”指令定义的后端主机列表中选取一台主机。nginx先使用负载均衡模块找到一台主机，再使用upstream模块实现与这台主机的交互。</li>
<li>Nginx负载均衡默认对后端服务器有健康检测的能力，仅限于端口检测，在后端服务器比较少的情况下负载均衡能力表现突出。</li>
<li>提醒：各种负载均衡策略尽量不要混合使用，这样会导致负载不均衡。<h4 id="Nginx负载均衡策略"><a href="#Nginx负载均衡策略" class="headerlink" title="Nginx负载均衡策略"></a>Nginx负载均衡策略</h4></li>
<li><p>轮询策略(<code>round-robin</code>)</p>
<ul>
<li>轮询策略是Nginx自带的负载均衡策略，并且是默认的策略。</li>
<li>每个请求按照访问时间顺序，分配到不同的后端服务器</li>
<li>配置如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">       server 192.168.1.101:8888;</span><br><span class="line">       server 192.168.1.102:8888;</span><br><span class="line">       server 192.168.1.103:8888;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>权重策略(<code>weight</code>)</p>
<ul>
<li>被指为轮询负载均衡策略的加强版，可以指定每个可选项的轮询频率</li>
<li>可以根据后端服务器的异质，能承受的负载程度来使用此策略</li>
<li>配置如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    server 192.168.1.101 weight=1; </span><br><span class="line">    server 192.168.1.102 weight=2;</span><br><span class="line">    server 192.168.1.103 weight=3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>基于IP的哈希策略(<code>ip_hash</code>)</p>
<ul>
<li>按照每个访问IP的hash计算结果来分配访问指定的后端服务器；这样可以对固定的访问源转发到固定的目的地址</li>
<li>这样可以解决集群中session一致性的问题</li>
<li>配置如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    ip_hash; </span><br><span class="line">    server 192.168.1.101:7777; </span><br><span class="line">    server 192.168.1.102:8888;</span><br><span class="line">    server 192.168.1.103:9999;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>公平分配策略(<code>fair</code>)(来自第三方)</p>
<ul>
<li>公平的按照后端服务器的响应时间(<code>rt</code>)来分配请求，响应时间短的优先分配访问</li>
<li>由于这种是第三方的负载均衡策略，如果Nginx要使用的话，需要往Nginx里面下载upstr_fair模块</li>
<li>配置如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">   fair;</span><br><span class="line">   server 192.168.1.101; </span><br><span class="line">   server 192.168.1.102; </span><br><span class="line">   server 192.168.1.103; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>基于URL的哈希策略(<code>url_hash</code>)(来自第三方)</p>
<ul>
<li>与IP_Hash类似，URL_Hash是根据请求的URL地址做哈希计算来分配请求值，力求每个相同的URL都能访问到相同的后端服务器</li>
<li>该策略主要用于缓存场景。根据缓存服务的请求参数，能提高命中同一台后端缓存服务器</li>
<li>使用的时候，同样，由于URL哈希属于第三方的负载均衡策略，要使用的话，需要按照这种负载均衡模块包以及指定哈希算法的hash软件包</li>
<li>配置如下：其中<code>hash_method</code>是哈希算法<br><pre><br>upstream backend {<br>server 192.168.1.101;<br>server 192.168.1.102;<br>server 192.168.1.103;<br>hash $request_uri;<br>hash_method crc32;<br>}<pre></pre></pre></li>
</ul>
</li>
</ol>

	
	</div>
  <a type="button" href="/archives/9b0bd708.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-10-17 </div>
			<div class="article-title"><a href="/archives/d1b4efa1.html" title="遍历Map对象的时候，遍历效率对于遍历的开销影响不小，需要谨慎选择">Java遍历Map对象的4种方法</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="Foreach遍历Map-Entry对象（O-n-）"><a href="#Foreach遍历Map-Entry对象（O-n-）" class="headerlink" title="Foreach遍历Map.Entry对象（O(n)）"></a>Foreach遍历Map.Entry对象（O(n)）</h4><ul>
<li>最普遍的遍历方式。但是遍历的Map不可为Null，需要做空指针判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//foreach遍历Entry实例</span><br><span class="line">public static void forEachMap(Map&lt;String,String&gt; stringMap)&#123;</span><br><span class="line">    if (stringMap==null) return;    //如果要遍历的Map为空，则终止遍历#NullPointerException</span><br><span class="line">    for (Map.Entry&lt;String,String&gt; entry : stringMap.entrySet())&#123;</span><br><span class="line">        System.out.println(&quot;key:&quot;+entry.getKey()+&quot;,value:&quot;+entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Foreach直接遍历key-value-（O-n-）"><a href="#Foreach直接遍历key-value-（O-n-）" class="headerlink" title="Foreach直接遍历key/value （O(n)）"></a>Foreach直接遍历key/value （O(n)）</h4><ul>
<li>通过Map的<code>keySet()</code>和<code>getValues()</code>对象直接获取key/value集合，再遍历得到数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//单独遍历Map对象中的key/value</span><br><span class="line">public static void forEachKeyOrValue(Map&lt;String,String&gt; map)&#123;</span><br><span class="line">    for (String key : map.keySet())&#123;</span><br><span class="line">        System.out.println(&quot;key:&quot;+key);</span><br><span class="line">    &#125;</span><br><span class="line">    for (String value : map.values())&#123;</span><br><span class="line">        System.out.println(&quot;value:&quot;+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="根据取出来的key集合来遍历value-（O-n-n-）"><a href="#根据取出来的key集合来遍历value-（O-n-n-）" class="headerlink" title="根据取出来的key集合来遍历value （O(n*n)）"></a>根据取出来的key集合来遍历value （O(n*n)）</h4><ul>
<li>这种方法有种多此一举的感觉…<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 先取出Map的key值，再通过遍历取出来的key来获取value值</span><br><span class="line"> * 但是该方法效率低，取出key已经很消耗资源，再遍历一遍value，已经是翻倍的成本</span><br><span class="line"> * */</span><br><span class="line">public static void forEachByKey(Map&lt;String,String&gt; map)&#123;</span><br><span class="line">    for (String key : map.keySet())&#123;</span><br><span class="line">        System.out.println(&quot;key:&quot;+key+&quot;,value:&quot;+map.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>####使用迭代器遍历Map对象 </p>
<ul>
<li><p>使用迭代器遍历Map的泛型数据<code>（O(n)）</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//通过迭代器Iterator遍历Map，使用泛型</span><br><span class="line">    public static void iteratorMap(Map&lt;String,String&gt; map)&#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String,String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(&quot;key:&quot;+entry.getKey()+&quot;,value:&quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用迭代器遍历键值数据<code>（O(n*n)）</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 先取出Map的key值，再通过遍历取出来的key来获取value值</span><br><span class="line"> * 但是该方法效率低，取出key已经很消耗资源，再遍历一遍value，已经是翻倍的成本</span><br><span class="line"> * */</span><br><span class="line">public static void forEachByKey(Map&lt;String,String&gt; map)&#123;</span><br><span class="line">    for (String key : map.keySet())&#123;</span><br><span class="line">        System.out.println(&quot;key:&quot;+key+&quot;,value:&quot;+map.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

	
	</div>
  <a type="button" href="/archives/d1b4efa1.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-09-30 </div>
			<div class="article-title"><a href="/archives/1ab741e2.html" title="数组类Array VS 静态类Arrays">Array与Arrays的区别</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="Array数组类"><a href="#Array数组类" class="headerlink" title="Array数组类"></a><code>Array</code>数组类</h4><ul>
<li><code>Array</code>数组是Java提供的一个基本的存储结构</li>
<li>提供了动态创建和访问 Java 数组的方法。其中的元素的类型必须相同</li>
<li>效率高，但是容量固定且无法改变；如果涉及扩展，需要重新创建数组并复制数据</li>
</ul>
<h4 id="Arrays静态类"><a href="#Arrays静态类" class="headerlink" title="Arrays静态类"></a><code>Arrays</code>静态类</h4><ul>
<li><code>Arrays</code>是一个数组的工具类，专门用于操作数组</li>
<li>具备齐全的处理工具方法；例如：搜索，排序，复制等静态方法</li>
</ul>

	
	</div>
  <a type="button" href="/archives/1ab741e2.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-09-29 </div>
			<div class="article-title"><a href="/archives/ad76721a.html" title="Collection是集合接口类；Collections是集合工具类">Collection与Collections的区别</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="java-util-Collection是一个集合接口"><a href="#java-util-Collection是一个集合接口" class="headerlink" title="java.util.Collection是一个集合接口"></a><code>java.util.Collection</code>是一个集合接口</h4><ul>
<li><code>Collection</code>是个接口类，旗下派生出我们常用以及不常用的一些容器，如下：</li>
<li><code>java.util.Collection</code><ul>
<li>Queue</li>
<li>Set<ul>
<li>AbstractSet<ul>
<li>HashSet<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>TreeSet</li>
</ul>
</li>
<li>SortSet</li>
</ul>
</li>
<li>List<ul>
<li>AbstractList<ul>
<li>ArrayList</li>
<li>AbstractSequentialList<ul>
<li>LinkedList</li>
</ul>
</li>
<li>Vector<ul>
<li>Stack</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="java-util-Collections-是一个静态工具类"><a href="#java-util-Collections-是一个静态工具类" class="headerlink" title="java.util.Collections 是一个静态工具类"></a><code>java.util.Collections</code> 是一个静态工具类</h4><ul>
<li><code>java.util.Collection</code>主要用于操作集合容器，工具方法齐全</li>
<li>提供一系列的静态方法实现对各种几何的搜索、排序、线程安全化等操作</li>
</ul>

	
	</div>
  <a type="button" href="/archives/ad76721a.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-09-01 </div>
			<div class="article-title"><a href="/archives/130dac3d.html" title="情人节活动需求开发后续总结：Set容器对象顺序引发的血案">Set集合误用引发的血案</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h4 id="需求场景："><a href="#需求场景：" class="headerlink" title="需求场景："></a>需求场景：</h4><ol>
<li>功能开发完成了，准备发布版本，准备下班。</li>
<li>从Redis的<code>Zset</code>的结构中，根据<code>score</code>的倒序取出有序集合数据</li>
</ol>
<h4 id="罪魁祸首的业务代码"><a href="#罪魁祸首的业务代码" class="headerlink" title="罪魁祸首的业务代码"></a>罪魁祸首的业务代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static Set&lt;String&gt; getZsetOrderByScore(final String key,final Long start , final Long end)&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return redisTemplate.execute(new RedisCallback&lt;Set&lt;String&gt;&gt;() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public Set&lt;String&gt; doInRedis(RedisConnection redisConnection) throws DataAccessException &#123;</span><br><span class="line">					Set&lt;byte[]&gt; set = redisConnection.zRevRange(redisTemplate.getStringSerializer().serialize(key),start,end);</span><br><span class="line"></span><br><span class="line">					Set&lt;String&gt; s = set.parallelStream().map(bytes -&gt; &#123;</span><br><span class="line">						return redisTemplate.getStringSerializer().deserialize(bytes);</span><br><span class="line">					&#125;).collect(Collectors.toSet());</span><br><span class="line">					return s;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			DEBUG.error(&quot;getZsetWithCol value to redis fail...&quot;, e);</span><br><span class="line">		&#125;</span><br><span class="line">		return Collections.emptySet();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引发问题："><a href="#引发问题：" class="headerlink" title="引发问题："></a>引发问题：</h4><ol>
<li>Redis中的<code>ZSet</code>数据排序正常，<code>score</code>的顺序也正常，经过上面代码取出来之后,<code>Set&lt;String&gt;</code>集合中的数据排序与Redis中的<code>ZSet</code>数据排序不一致。导致数据展示错误</li>
<li>出现问题，不能发版本，deadline在这，还是得把问题解决。</li>
</ol>
<h4 id="问题排查："><a href="#问题排查：" class="headerlink" title="问题排查："></a>问题排查：</h4><ol>
<li>把刚刚从Redis中取出来的数据，反序列化之后，直接打印出来，发现数据顺序与Redis一直；排除Java代码从Redis中查询数据的时候发生顺序错误这个猜测</li>
<li>随着数据流向，问题定位网上抛。判断刚刚反序列化就打印的数据顺序与<code>Set&lt;String&gt;</code>容器对象中的顺序，发现两者顺序不一致，发生顺序错误。</li>
<li>问题定位在反序列化数据之后，装载在<code>Set&lt;String&gt;</code>容器的时候，发送顺序错乱。</li>
</ol>
<h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><ul>
<li>使用lambda表达式的时候，聚合集合操作<code>Collectors.toSet()</code>打乱了数据的顺序</li>
<li><code>Collectors.toSet()</code>本质是重新组装<code>Set</code>集合，先看看<code>Set</code>集合是否会对集合对象进行重新排序？<br><pre><br>Set<string> set = new HashSet&lt;&gt;();<pre><code>set.add(&quot;m&quot;);
set.add(&quot;a&quot;);
set.add(&quot;e&quot;);
System.out.println(set);
//打印结果：[a, e, m]
</code></pre><pre></pre></string></pre></li>
<li>果然问题出现在这里，幸好没去翻lambda的聚合源码</li>
<li>HashSet内部使用元素的自然顺序对元素进行排序，或者根据创建set时提供的Comparator进行排序</li>
<li>HashSet使用哈希函数对数据进寻址排序，所以数据是重新排序过的。</li>
</ul>
<h4 id="BUG-FIXED"><a href="#BUG-FIXED" class="headerlink" title="BUG FIXED"></a>BUG FIXED</h4><ol>
<li>在从取出来的数据反序列化完成之后，不使用<code>Set</code>集合来存方对象，使用<code>List</code>代替之。</li>
<li>如果能获取到Redis数据的score数值的话，也可以通过重写Comparator方法，来通过score数据排序。</li>
</ol>

	
	</div>
  <a type="button" href="/archives/130dac3d.html#more" class="btn btn-default more">阅读此文</a>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
          <li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>上一页</a></li>
        

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/2/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			<div class="widget">
    
</div>

		
			
		
			
	<div class="widget">
		<h4>标签云</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/RabbitMQ/">RabbitMQ<span>1</span></a></li>
		
			<li><a href="/tags/leetcode/">leetcode<span>1</span></a></li>
		
			<li><a href="/tags/Nginx/">Nginx<span>1</span></a></li>
		
			<li><a href="/tags/Web/">Web<span>3</span></a></li>
		
			<li><a href="/tags/Exception/">Exception<span>1</span></a></li>
		
			<li><a href="/tags/Servlet/">Servlet<span>2</span></a></li>
		
			<li><a href="/tags/TakeDown/">TakeDown<span>4</span></a></li>
		
			<li><a href="/tags/Spring/">Spring<span>5</span></a></li>
		
			<li><a href="/tags/Linux/">Linux<span>2</span></a></li>
		
			<li><a href="/tags/Git/">Git<span>2</span></a></li>
		
			<li><a href="/tags/Hibernate/">Hibernate<span>2</span></a></li>
		
			<li><a href="/tags/V2ray/">V2ray<span>1</span></a></li>
		
			<li><a href="/tags/Angular-JS/">Angular JS<span>2</span></a></li>
		
			<li><a href="/tags/Maven/">Maven<span>1</span></a></li>
		
			<li><a href="/tags/Redis/">Redis<span>4</span></a></li>
		
			<li><a href="/tags/动态代理/">动态代理<span>4</span></a></li>
		
			<li><a href="/tags/场景/">场景<span>1</span></a></li>
		
			<li><a href="/tags/多线程/">多线程<span>4</span></a></li>
		
			<li><a href="/tags/Mybatis/">Mybatis<span>4</span></a></li>
		
			<li><a href="/tags/struts2/">struts2<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>24</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/archives/27e17559.html"  title="redis总的所有数据默认保存在内存当中的.但场景需要，有时候需要进行持久化保存" ><i class="fa fa-file-o"></i>Redis持久化方案</a>
      </li>
    
      <li>
        <a href="/archives/3eac123.html"  title="当一个系统访问量上来的时候，不只是数据库性能瓶颈问题了，数据库数据安全也会浮现，这时候合理使用数据库锁机制就显得异常重要了。" ><i class="fa fa-file-o"></i>数据库锁机制分类</a>
      </li>
    
      <li>
        <a href="/archives/7ffea1fe.html"  title="RabbitMQ消息作为分布式消息协同工具，承担者协同各个系统之间的正常通信。如何确保消息通过RabbitMQ传输而不丢失数据？" ><i class="fa fa-file-o"></i>RabbitMQ消息可靠性</a>
      </li>
    
      <li>
        <a href="/archives/28d7adef.html"  title="快速失败：当在迭代一个集合的时候，如果有另外一个线程在修改这个集合，就会抛出ConcurrentModification异常，java.util下都是快速失败。 安全失败：在迭代时候会在集合二层做一个拷贝，所以在修改集合上层元素不会影响下层。在java.util.concurrent下都是安全失败" ><i class="fa fa-file-o"></i>快速失败与安全失败机制</a>
      </li>
    
      <li>
        <a href="/archives/a1cd7aa8.html"  title="从Integer缓存池的角度看Integer比较大小" ><i class="fa fa-file-o"></i>Integer封装类比较大小</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/RicoNut" title="My Github account." target="_blank"]);">RicoNut Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


    </div>
  </div>
  <div class="container-narrow">
    <footer> <p>
  &copy; 2019 Rico Nut
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
</html>